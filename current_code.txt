// Consolidated Code Extracted on 1-1-2025 16:31:57

// File: TempleOfDoom.Presentation\ColorManager.cs
namespace TempleOfDoom.Presentation
{
    public static class ColorManager
    {
        // If you want, these could be loaded from a config file or a JSON in the future.
        // Default colors
        private static readonly ConsoleColor DefaultTileColor = ConsoleColor.White;
        private static readonly ConsoleColor DefaultItemColor = ConsoleColor.White;
        private static readonly ConsoleColor PlayerColor = ConsoleColor.Blue; // Example for the player
        // Dictionaries for quick lookups
        private static Dictionary<string, ConsoleColor> tileColors = new Dictionary<string, ConsoleColor>
        {
            // Map tile type names to colors
            { nameof(WallTile), ConsoleColor.Yellow },
            { nameof(FloorTile), ConsoleColor.Gray },
            { nameof(DoorTile), ConsoleColor.DarkGray }
            // Add more tile types here in the future
        };
        private static Dictionary<string, ConsoleColor> itemColors = new Dictionary<string, ConsoleColor>
        {
            // Map item "type" names or known names to colors
            // We'll handle keys separately since they contain their color in the name.
            { "Sankara Stone", ConsoleColor.DarkYellow }, // approximation for "orange"
            { "BoobyTrap", ConsoleColor.DarkRed },
            { "Disappearing BoobyTrap", ConsoleColor.Red },
            { "Pressure Plate", ConsoleColor.Cyan }
            // Keys will be handled dynamically
        };
        public static ConsoleColor GetColorForTile(ITile tile)
        {
            string tileTypeName = tile.GetType().Name;
            if (tileColors.ContainsKey(tileTypeName))
            {
                return tileColors[tileTypeName];
            }
            return DefaultTileColor;
        }
        public static ConsoleColor GetColorForItem(IItem item)
        {
            // Keys have color embedded in their name, e.g. "Key(green)", "Key(red)"
            if (item.Name.StartsWith("Key("))
            {
                return GetKeyColor(item.Name);
            }
            if (itemColors.ContainsKey(item.Name))
            {
                return itemColors[item.Name];
            }
            return DefaultItemColor;
        }
        public static ConsoleColor GetColorForPlayer()
        {
            return PlayerColor;
        }
        private static ConsoleColor GetKeyColor(string keyName)
        {
            // keyName format: "Key(color)"
            // Extract the color from between parentheses
            int start = keyName.IndexOf('(') + 1;
            int end = keyName.IndexOf(')');
            if (start > 0 && end > start)
            {
                string colorStr = keyName.Substring(start, end - start).ToLower();
                return colorStr switch
                {
                    "red" => ConsoleColor.Red,
                    "green" => ConsoleColor.Green,
                    "blue" => ConsoleColor.Blue, // If you ever have a blue key
                    _ => DefaultItemColor
                };
            }
            return DefaultItemColor;
        }
    }
}

// File: TempleOfDoom.Presentation\InputHandler.cs
namespace TempleOfDoom.Presentation
{
    public static class InputHandler
    {
        public static Direction? GetDirectionFromInput(ConsoleKey key)
        {
            return key switch
            {
                ConsoleKey.UpArrow or ConsoleKey.W => Direction.North,
                ConsoleKey.DownArrow or ConsoleKey.S => Direction.South,
                ConsoleKey.LeftArrow or ConsoleKey.A => Direction.West,
                ConsoleKey.RightArrow or ConsoleKey.D => Direction.East,
                _ => null
            };
        }
    }
}

// File: TempleOfDoom.Presentation\Program.cs
namespace TempleOfDoom.Presentation
{
    public class Program
    {
        private static bool StartGame = false;
        public static void Main(string[] args)
        {
            if (StartGame)
            {
                Console.OutputEncoding = System.Text.Encoding.UTF8;
                string filePath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Resources", "TempleOfDoom.json");
                JsonLevelLoader loader = new JsonLevelLoader();
                LevelDto levelData = loader.LoadLevel(filePath);
                IItemFactory itemFactory = new DefaultItemFactory();
                Dictionary<int, Room> roomsById = new Dictionary<int, Room>();
                foreach (var roomDto in levelData.Rooms)
                {
                    Room room = LevelMapper.MapRoomDtoToRoom(roomDto, itemFactory);
                    roomsById[room.Id] = room;
                }
                LevelMapper.ApplyConnectionsToRooms(levelData.Connections, roomsById);
                var roomConnections = LevelMapper.CreateRoomConnectionMap(levelData.Connections);
                Player player = LevelMapper.MapPlayerDtoToPlayer(levelData.Player);
                Room currentRoom = roomsById[levelData.Player.StartRoomId];
                GameService gameService = new GameService(currentRoom, player, roomsById, roomConnections);
                Console.OutputEncoding = System.Text.Encoding.UTF8;
                bool isRunning = true;
                while (isRunning)
                {
                    if (gameService.IsGameOver)
                    {
                        // Game ended (win or lose)
                        Console.Clear();
                        if (gameService.IsWin)
                        {
                            Renderer.RenderWinScreen();
                        }
                        else if (gameService.IsLose)
                        {
                            Renderer.RenderLoseScreen();
                        }
                        break;
                    }
                    Console.Clear();
                    Renderer.RenderRoom(gameService.CurrentRoom, gameService.Player);
                    Renderer.RenderPlayerStatus(gameService.Player, gameService.CurrentRoom);
                    ConsoleKeyInfo keyInfo = Console.ReadKey(true);
                    Direction? direction = InputHandler.GetDirectionFromInput(keyInfo.Key);
                    if (direction.HasValue)
                    {
                        gameService.HandlePlayerMovement(direction.Value);
                    }
                    else if (keyInfo.Key == ConsoleKey.Escape)
                    {
                        isRunning = false;
                    }
                }
                // Wait for a key press before closing
                Console.WriteLine("Press any key to exit...");
                Console.ReadKey(true);
            }
            else
            {
                ExtractAndOpenCode();
            }
        }
        private static void ExtractAndOpenCode()
        {
            // Define the project root path. Adjust this path as needed to get to the solution folder
            string projectRootPath = Path.GetFullPath(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "..", "..", "..", ".."));
            // Define the output file path. For example, place it in a "Output" folder within the project directory.
            string outputFilePath = Path.Combine(projectRootPath, "current_code.txt");
            // Use the CodeExtractor class to perform the extraction
            string[] includedDirectories = new string[] { "TempleOfDoom.Presentation", "TempleOfDoom.BusinessLogic", "TempleOfDoom.DataAccess" };
            CodeExtractor.ExtractCodeToTxt(projectRootPath, outputFilePath, includedDirectories);
            // Use the FileOpener class to open the output file
            FileOpener.OpenFile(outputFilePath);
        }
    }
}

// File: TempleOfDoom.Presentation\Renderer.cs
namespace TempleOfDoom.Presentation
{
    public static class Renderer
    {
        public static void RenderRoom(Room room, Player player)
        {
            for (int y = 0; y < room.Height; y++)
            {
                for (int x = 0; x < room.Width; x++)
                {
                    var coords = new Coordinates(x, y);
                    if (coords.Equals(player.Position))
                    {
                        Console.ForegroundColor = ColorManager.GetColorForPlayer();
                        Console.Write("X ");
                        Console.ResetColor();
                    }
                    else
                    {
                        var tile = room.GetTileAt(coords);
                        if (tile is ItemTileDecorator itemTile)
                        {
                            Console.ForegroundColor = ColorManager.GetColorForItem(itemTile.Item);
                            Console.Write($"{itemTile.Representation} ");
                            Console.ResetColor();
                        }
                        else if (tile is DoorTile doorTile)
                        {
                            var doorColor = doorTile.GetDoorColor();
                            Console.ForegroundColor = doorColor;
                            Console.Write($"{doorTile.Representation} ");
                            Console.ResetColor();
                        }
                        else
                        {
                            Console.ForegroundColor = ColorManager.GetColorForTile(tile);
                            Console.Write($"{tile.Representation} ");
                            Console.ResetColor();
                        }
                    }
                }
                Console.WriteLine();
            }
        }
        public static void RenderPlayerStatus(Player player, Room currentRoom)
        {
            Console.WriteLine();
            Console.WriteLine($"Current Room: {currentRoom.Id}");
            Console.WriteLine($"Lives: {player.Lives}");
            Console.Write("Inventory: ");
            if (player.Inventory.Count == 0)
            {
                Console.WriteLine("Empty");
            }
            else
            {
                foreach (var item in player.Inventory)
                {
                    Console.ForegroundColor = ColorManager.GetColorForItem(item);
                    Console.Write($"{item.Name}, ");
                    Console.ResetColor();
                }
                Console.WriteLine();
            }
        }
        public static void RenderWinScreen()
        {
            Console.ForegroundColor = ConsoleColor.Green;
            Console.WriteLine("****************************************************");
            Console.WriteLine("                   YOU WIN!                         ");
            Console.WriteLine("You have collected all the Sankara Stones!          ");
            Console.WriteLine("****************************************************");
            Console.ResetColor();
        }
        public static void RenderLoseScreen()
        {
            Console.ForegroundColor = ConsoleColor.Red;
            Console.WriteLine("****************************************************");
            Console.WriteLine("                   YOU LOSE!                        ");
            Console.WriteLine("You ran out of lives. Better luck next time.        ");
            Console.WriteLine("****************************************************");
            Console.ResetColor();
        }
    }
}

// File: TempleOfDoom.Presentation\RemoveLater\CodeExtractor.cs
namespace TempleOfDoom.BusinessLogic
{
    public static class CodeExtractor
    {
        /// <summary>
        /// Extracts code from the specified directories and consolidates it into a single text file.
        /// </summary>
        /// <param name="projectRootPath">The root path of the project.</param>
        /// <param name="outputFilePath">The output file path where the consolidated code will be saved.</param>
        /// <param name="includedDirectories">An array of directories to include in the extraction.</param>
        public static void ExtractCodeToTxt(string projectRootPath, string outputFilePath, string[] includedDirectories)
        {
            try
            {
                // Ensure the output directory exists
                string outputDirectory = Path.GetDirectoryName(outputFilePath);
                if (!Directory.Exists(outputDirectory))
                {
                    Directory.CreateDirectory(outputDirectory);
                    Console.WriteLine($"Created output directory: {outputDirectory}");
                }
                // Initialize or clear the output file and write the header
                {
                    writer.WriteLine("// Consolidated Code Extracted on " + DateTime.Now);
                    writer.WriteLine();
                }
                // Define directories to exclude
                var excludedDirectories = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
                {
                    "bin",
                    "obj",
                    ".git",
                    ".vs",
                    "Properties",
                    "Resources" // Add other directories as needed
                };
                // Retrieve all .cs files from the specified included directories
                var csFiles = includedDirectories.SelectMany(dir => Directory.GetFiles(Path.Combine(projectRootPath, dir), "*.cs", SearchOption.AllDirectories))
                    .Where(file => !excludedDirectories.Any(exDir =>
                        Path.GetFullPath(file)
                            .Split(Path.DirectorySeparatorChar)
                            .Contains(exDir, StringComparer.OrdinalIgnoreCase)));
                if (!csFiles.Any())
                {
                    Console.WriteLine("No .cs files found in the specified directories.");
                    return;
                }
                Console.WriteLine($"Found {csFiles.Count()} .cs files. Processing...");
                foreach (var file in csFiles)
                {
                    try
                    {
                        // Read all lines from the current file
                        var lines = File.ReadAllLines(file);
                        // Filter out 'using' directives
                        var filteredLines = lines.Where(line => !Regex.IsMatch(line.Trim(), @"^using\s+")).ToList();
                        // Optionally, remove empty lines for cleaner output
                        filteredLines = filteredLines.Where(line => !string.IsNullOrWhiteSpace(line)).ToList();
                        // Prepare content to append
                        var header = $"// File: {Path.GetRelativePath(projectRootPath, file)}";
                        var content = string.Join(Environment.NewLine, filteredLines);
                        // Append to the output file
                        {
                            writer.WriteLine(header);
                            writer.WriteLine(content);
                            writer.WriteLine(); // Add a newline for separation
                        }
                        Console.WriteLine($"Processed: {Path.GetRelativePath(projectRootPath, file)}");
                    }
                    catch (Exception exFile)
                    {
                        Console.WriteLine($"Error processing file {file}: {exFile.Message}");
                    }
                }
                Console.WriteLine($"Extraction complete. Check the '{outputFilePath}' file.");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"An error occurred during extraction: {ex.Message}");
            }
        }
    }
}

// File: TempleOfDoom.Presentation\RemoveLater\FileOpener.cs
namespace TempleOfDoom.Presentation.RemoveLater
{
    public static class FileOpener
    {
        /// <summary>
        /// Opens the specified file in the default application.
        /// </summary>
        /// <param name="filePath">The full path to the file to open.</param>
        public static void OpenFile(string filePath)
        {
            try
            {
                Console.WriteLine($"Attempting to open file: {filePath}");
                System.Diagnostics.Process.Start(new System.Diagnostics.ProcessStartInfo()
                {
                    FileName = filePath,
                    UseShellExecute = true
                });
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Failed to open the file: {ex.Message}");
            }
        }
    }
}

// File: TempleOfDoom.BusinessLogic\GameService.cs
public class GameService
{
    private Dictionary<int, Room> _roomsById; 
    private IGameStateManager _gameStateManager;
    private IPlayerMovementController _playerMovementController;
    private IItemCollector _itemCollector;
    public Room CurrentRoom { get; private set; }
    public Player Player { get; private set; }
    public bool IsWin => _gameStateManager.IsWin;
    public bool IsLose => _gameStateManager.IsLose;
    public bool IsGameOver => _gameStateManager.IsGameOver;
    public GameService(
        Room currentRoom,
        Player player,
        Dictionary<int, Room> roomsById,
        Dictionary<int, Dictionary<Direction, int>> roomConnections)
    {
        // Removed: Instance = this;
        _roomsById = roomsById; // CHANGED: Store a reference
        _gameStateManager = new GameStateManager();
        IDoorService doorService = new DoorService();
        IItemCollector itemCollector = new ItemCollector();
        itemCollector.InitializeTotalStones(_roomsById.Values);
        itemCollector.SetGameStateManager(_gameStateManager);
        IRoomTransitionService roomTransitionService = new RoomTransitionService(roomConnections, doorService, _roomsById); // CHANGED: pass roomsById
        IMovementStrategy movementStrategy = new DefaultMovementStrategy();
        IPlayerMovementController movementController = new PlayerMovementController(movementStrategy, roomTransitionService, doorService, itemCollector, _gameStateManager);
        _itemCollector = itemCollector;
        _playerMovementController = movementController;
        CurrentRoom = currentRoom;
        Player = player;
    }
    public void HandlePlayerMovement(Direction direction)
    {
        if (IsGameOver) return;
        if (_playerMovementController.TryMovePlayer(Player, CurrentRoom, direction, out var newRoom))
        {
            if (newRoom != CurrentRoom)
            {
                SetCurrentRoom(newRoom);
            }
        }
    }
    public void SetCurrentRoom(Room room)
    {
        CurrentRoom = room;
    }
}

// File: TempleOfDoom.BusinessLogic\ItemCollector.cs
namespace TempleOfDoom.BusinessLogic
{
    public class ItemCollector : IItemCollector
    {
        private int _totalStones;
        private int _collectedStones;
        private IGameStateManager _gameStateManager;
        public void InitializeTotalStones(IEnumerable<Room> rooms)
        {
            _totalStones = rooms.SelectMany(r => r.Layout.Cast<ITile>())
                .OfType<ItemTileDecorator>()
                .Count(t => t.Item is SankaraStone);
        }
        public void SetGameStateManager(IGameStateManager gameStateManager)
        {
            _gameStateManager = gameStateManager;
        }
        public bool HandleItemInteraction(Player player, Room room)
        {
            var tile = room.GetTileAt(player.Position);
            if (tile is ItemTileDecorator itemTile)
            {
                bool shouldRemove = itemTile.Item.OnPlayerEnter(player, room);
                if (player.Lives <= 0)
                {
                    _gameStateManager?.MarkLose();
                    return true;
                }
                if (shouldRemove)
                {
                    if (itemTile.Item is SankaraStone)
                    {
                        _collectedStones++;
                        if (_collectedStones == _totalStones)
                        {
                            _gameStateManager?.MarkWin();
                        }
                    }
                    room.RemoveItemAt(player.Position);
                }
            }
            return false;
        }
    }
}

// File: TempleOfDoom.BusinessLogic\LevelMapper.cs
namespace TempleOfDoom.BusinessLogic.Mappers
{
    public static class LevelMapper
    {
        public static Room MapRoomDtoToRoom(RoomDto roomDto, IItemFactory itemFactory)
        {
            var room = new Room(roomDto.Width, roomDto.Height)
            {
                Id = roomDto.Id,
                Type = roomDto.Type
            };
            room.GenerateLayout();
            if (roomDto.Items != null)
            {
                foreach (var itemDto in roomDto.Items)
                {
                    var item = itemFactory.CreateItem(itemDto);
                    room.PlaceItem(new Coordinates(itemDto.X, itemDto.Y), item);
                }
            }
            return room;
        }
        public static Player MapPlayerDtoToPlayer(PlayerDto playerDto)
        {
            return new Player(playerDto.StartX, playerDto.StartY, playerDto.Lives);
        }
        public static void ApplyConnectionsToRooms(List<ConnectionDto> connections, Dictionary<int, Room> rooms)
        {
            foreach (var connection in connections)
            {
                // Apply to north/south
                if (connection.NORTH.HasValue && connection.SOUTH.HasValue)
                {
                    IDoor door = DoorFactory.CreateCompositeDoor(connection.Doors);
                    CreateDoorTileForRoom(rooms[connection.NORTH.Value], Direction.South, door);
                    CreateDoorTileForRoom(rooms[connection.SOUTH.Value], Direction.North, door);
                }
                // East/West
                if (connection.EAST.HasValue && connection.WEST.HasValue)
                {
                    IDoor door = DoorFactory.CreateCompositeDoor(connection.Doors);
                    CreateDoorTileForRoom(rooms[connection.EAST.Value], Direction.West, door);
                    CreateDoorTileForRoom(rooms[connection.WEST.Value], Direction.East, door);
                }
                // If in part 2 you have UPPER/LOWER or portals, you'd handle them here similarly.
            }
        }
        private static void CreateDoorTileForRoom(Room room, Direction direction, IDoor door)
        {
            bool isHorizontal = (direction == Direction.North || direction == Direction.South);
            Coordinates doorPosition = GetDoorPosition(room, direction);
            room.Layout[doorPosition.Y, doorPosition.X] = new DoorTile(door, isHorizontal);
            // Register if needed
            if (door is ToggleDoorDecorator || door is DoorDecorator)
            {
                room.RegisterDoor(door);
            }
        }
        private static Coordinates GetDoorPosition(Room room, Direction direction)
        {
            int doorX = 0, doorY = 0;
            switch (direction)
            {
                case Direction.North: doorX = room.Width / 2; doorY = 0; break;
                case Direction.South: doorX = room.Width / 2; doorY = room.Height - 1; break;
                case Direction.West: doorX = 0; doorY = room.Height / 2; break;
                case Direction.East: doorX = room.Width - 1; doorY = room.Height / 2; break;
            }
            return new Coordinates(doorX, doorY);
        }
        public static Dictionary<int, Dictionary<Direction, int>> CreateRoomConnectionMap(List<ConnectionDto> connections)
        {
            var map = new Dictionary<int, Dictionary<Direction, int>>();
            foreach (var conn in connections)
            {
                if (conn.NORTH.HasValue && conn.SOUTH.HasValue)
                {
                    AddConnection(map, conn.NORTH.Value, Direction.South, conn.SOUTH.Value);
                    AddConnection(map, conn.SOUTH.Value, Direction.North, conn.NORTH.Value);
                }
                if (conn.EAST.HasValue && conn.WEST.HasValue)
                {
                    AddConnection(map, conn.EAST.Value, Direction.West, conn.WEST.Value);
                    AddConnection(map, conn.WEST.Value, Direction.East, conn.EAST.Value);
                }
            }
            return map;
        }
        private static void AddConnection(Dictionary<int, Dictionary<Direction, int>> map, int fromRoomId, Direction dir, int toRoomId)
        {
            if (!map.ContainsKey(fromRoomId))
                map[fromRoomId] = new Dictionary<Direction, int>();
            map[fromRoomId][dir] = toRoomId;
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Decorators\DoorDecorator.cs
namespace TempleOfDoom.BusinessLogic.Decorators
{
    public abstract class DoorDecorator : IDoor
    {
        protected readonly IDoor _wrappedDoor;
        protected DoorDecorator(IDoor wrappedDoor)
        {
            _wrappedDoor = wrappedDoor;
        }
        // Public property to access the wrapped door
        public IDoor WrappedDoor => _wrappedDoor;
        public virtual char GetRepresentation(bool isHorizontal)
        {
            return _wrappedDoor.GetRepresentation(isHorizontal);
        }
        public virtual ConsoleColor GetColor()
        {
            return _wrappedDoor.GetColor();
        }
        public virtual bool IsOpen(Player player, Room currentRoom)
        {
            return _wrappedDoor.IsOpen(player, currentRoom);
        }
        public virtual void NotifyStateChange()
        {
            _wrappedDoor.NotifyStateChange();
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Decorators\ItemTileDecorator.cs
namespace TempleOfDoom.BusinessLogic.Decorators
{
    public class ItemTileDecorator : Tile
    {
        private readonly Tile _baseTile;
        public IItem Item { get; }
        public ItemTileDecorator(Tile baseTile, IItem item)
        {
            _baseTile = baseTile;
            Item = item;
        }
        public override string Representation => GetItemRepresentation();
        public override bool IsWalkable => _baseTile.IsWalkable;
        private string GetItemRepresentation()
        {
            // Represent items with their first letter or a specific symbol
            return Item.Name switch
            {
                "Sankara Stone" => "S",
                "Key(green)" => "K",
                "Key(red)" => "K",
                "BoobyTrap" => "O",
                "Disappearing BoobyTrap" => "@",
                "Pressure Plate" => "T",
                _ => "?"
            };
        }
        public ITile GetBaseTile() => _baseTile;
    }
}

// File: TempleOfDoom.BusinessLogic\Enum\Direction.cs
namespace TempleOfDoom.BusinessLogic.Enum
{
    public enum Direction
    {
        North,
        South,
        East,
        West
    }
}

// File: TempleOfDoom.BusinessLogic\Factories\DefaultItemFactory.cs
namespace TempleOfDoom.BusinessLogic.Factories
{
    public class DefaultItemFactory : IItemFactory
    {
        public IItem CreateItem(ItemDto itemDto)
        {
            return itemDto.Type.ToLower() switch
            {
                "sankara stone" => new SankaraStone(),
                "key" => new KeyItem(itemDto.Color),
                "boobytrap" => new BoobyTrap(itemDto.Damage ?? 1),
                "disappearing boobytrap" => new DisappearingBoobyTrap(itemDto.Damage ?? 1),
                "pressure plate" => new PressurePlate(),
                _ => throw new ArgumentException($"Unknown item type: {itemDto.Type}")
            };
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Factories\DoorFactory.cs
namespace TempleOfDoom.BusinessLogic.Factories
{
    public static class DoorFactory
    {
        public static IDoor CreateCompositeDoor(List<DoorDto> doorDtos)
        {
            // If no door info, return a bare door
            if (doorDtos == null || doorDtos.Count == 0)
            {
                return new DefaultDoor();
            }
            // Start with the "plain" door
            IDoor doorChain = new DefaultDoor();
            // Decorate for each door type
            foreach (var dto in doorDtos)
            {
                doorChain = WrapDoor(doorChain, dto);
            }
            return doorChain;
        }
        private static IDoor WrapDoor(IDoor baseDoor, DoorDto doorDto)
        {
            switch (doorDto.Type.ToLower())
            {
                case "colored":
                    return new ColoredDoorDecorator(baseDoor, doorDto.Color);
                case "toggle":
                    return new ToggleDoorDecorator(baseDoor);
                case "closing gate":
                    return new ClosingGateDoorDecorator(baseDoor);
                case "open on odd":
                    return new OpenOnOddDoorDecorator(baseDoor);
                case "open on stones in room":
                    return new OpenOnStonesInRoomDecorator(baseDoor, doorDto.NoOfStones ?? 0);
                // If some unknown type, just return baseDoor or optionally throw
                default:
                    return baseDoor;
            }
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Helpers\DirectionHelper.cs
namespace TempleOfDoom.BusinessLogic.Helpers
{
    public static class DirectionHelper
    {
        public static Coordinates ToCoordinates(Direction direction)
        {
            return direction switch
            {
                Direction.North => new Coordinates(0, -1),
                Direction.South => new Coordinates(0, 1),
                Direction.West => new Coordinates(-1, 0),
                Direction.East => new Coordinates(1, 0),
                _ => new Coordinates(0, 0)
            };
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Interfaces\IDoor.cs
namespace TempleOfDoom.BusinessLogic.Interfaces
{
    public interface IDoor
    {
        char GetRepresentation(bool isHorizontal);
        ConsoleColor GetColor();
        bool IsOpen(Player player, Room currentRoom);
        // Some doors might need to be toggled externally (e.g., pressure plates)
        void NotifyStateChange();
    }
}

// File: TempleOfDoom.BusinessLogic\Interfaces\IDoorService.cs
namespace TempleOfDoom.BusinessLogic.Interfaces
{
    public interface IDoorService
    {
        bool CanPassThroughDoor(Player player, Room room, Direction direction);
        void AfterPassingDoor(Room room, Direction direction);
    }
}

// File: TempleOfDoom.BusinessLogic\Interfaces\IGameStateManager.cs
namespace TempleOfDoom.BusinessLogic.Interfaces
{
    public interface IGameStateManager
    {
        bool IsWin { get; }
        bool IsLose { get; }
        bool IsGameOver { get; }
        void MarkWin();
        void MarkLose();
        // Possibly notify about life changes, stone count changes, etc.
    }
}

// File: TempleOfDoom.BusinessLogic\Interfaces\IItem.cs
namespace TempleOfDoom.BusinessLogic.Interfaces
{
    public interface IItem
    {
        string Name { get; }
        bool IsCollectible { get; }
        bool OnPlayerEnter(Player player, Room currentRoom); 
    }
}

// File: TempleOfDoom.BusinessLogic\Interfaces\IItemCollector.cs
namespace TempleOfDoom.BusinessLogic.Interfaces
{
    public interface IItemCollector
    {
        void InitializeTotalStones(IEnumerable<Room> rooms);
        bool HandleItemInteraction(Player player, Room room);
        // Possibly a method to check if all stones collected and notify state manager
        void SetGameStateManager(IGameStateManager gameStateManager);
    }
}

// File: TempleOfDoom.BusinessLogic\Interfaces\IItemFactory.cs
namespace TempleOfDoom.BusinessLogic.Interfaces
{
    public interface IItemFactory
    {
        IItem CreateItem(ItemDto itemDto);
    }
}

// File: TempleOfDoom.BusinessLogic\Interfaces\IMovementStrategy.cs
namespace TempleOfDoom.BusinessLogic.Interfaces
{
    public interface IMovementStrategy
    {
        /// <summary>
        /// Calculates the next position for the player given a direction.
        /// </summary>
        Coordinates GetNextPosition(Player player, Room currentRoom, Direction direction);
    }
}

// File: TempleOfDoom.BusinessLogic\Interfaces\IPlayerMovementController.cs
namespace TempleOfDoom.BusinessLogic.Interfaces
{
    public interface IPlayerMovementController
    {
        /// <summary>
        /// Attempt to move the player in the given direction inside the current room.
        /// Returns true if moved or transitioned, false otherwise.
        /// If room transition occurs, the new room is returned in newCurrentRoom.
        /// </summary>
        bool TryMovePlayer(Player player, Room currentRoom, Direction direction, out Room newCurrentRoom);
    }
}

// File: TempleOfDoom.BusinessLogic\Interfaces\IRoomTransitionService.cs
namespace TempleOfDoom.BusinessLogic.Interfaces
{
    public interface IRoomTransitionService
    {
        bool TryTransition(Room currentRoom, Player player, Direction direction, out Room nextRoom);
    }
}

// File: TempleOfDoom.BusinessLogic\Interfaces\ITile.cs
namespace TempleOfDoom.BusinessLogic.Interfaces
{
    public interface ITile
    {
        string Representation { get; }
        bool IsWalkable { get; }
    }
}

// File: TempleOfDoom.BusinessLogic\Manager\GameStateManager.cs
namespace TempleOfDoom.BusinessLogic.Manager
{
    public class GameStateManager : IGameStateManager
    {
        public bool IsWin { get; private set; }
        public bool IsLose { get; private set; }
        public bool IsGameOver => IsWin || IsLose;
        public void MarkWin() => IsWin = true;
        public void MarkLose() => IsLose = true;
    }
}

// File: TempleOfDoom.BusinessLogic\Models\Player.cs
namespace TempleOfDoom.BusinessLogic.Models
{
    public class Player
    {
        public Coordinates Position { get; private set; }
        public int Lives { get; set; }
        public List<IItem> Inventory { get; } = new List<IItem>();
        public Player(int x, int y, int lives = 3)
        {
            Position = new Coordinates(x, y);
            Lives = lives;
        }
        public Coordinates GetNewPosition(Direction direction)
        {
            Coordinates movement = DirectionHelper.ToCoordinates(direction);
            return Position + movement;
        }
        public void UpdatePosition(Coordinates newPosition)
        {
            Position = newPosition;
        }
        public bool TryMove(Direction direction, Room currentRoom)
        {
            Coordinates newPosition = GetNewPosition(direction);
            // Check boundaries
            if (newPosition.X < 0 || newPosition.X >= currentRoom.Width ||
                newPosition.Y < 0 || newPosition.Y >= currentRoom.Height)
            {
                // Can't move inside this room; might trigger AttemptRoomTransition if standing on a door.
                return false;
            }
            if (!currentRoom.GetTileAt(newPosition).IsWalkable)
            {
                return false;
            }
            Position = newPosition;
            return true;
        }
        public void CollectItem(IItem item)
        {
            if (item.IsCollectible)
            {
                Inventory.Add(item);
            }
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Models\Room.cs
namespace TempleOfDoom.BusinessLogic.Models
{
    public class Room
    {
        private List<IDoor> _doors = new List<IDoor>();
        public int Id { get; set; }
        public string Type { get; set; }
        public int Width { get; set; }
        public int Height { get; set; }
        public ITile[,] Layout { get; private set; }
        public Room(int width, int height)
        {
            Width = width;
            Height = height;
            Layout = new ITile[Height, Width];
        }
        public ITile GetTileAt(Coordinates coordinates) => Layout[coordinates.Y, coordinates.X];
        public void GenerateLayout()
        {
            for (int y = 0; y < Height; y++)
            {
                for (int x = 0; x < Width; x++)
                {
                    Layout[y, x] = (x == 0 || y == 0 || x == Width - 1 || y == Height - 1)
                        ? (ITile)new WallTile()
                        : new FloorTile();
                }
            }
        }
        public void PlaceItem(Coordinates position, IItem item)
        {
            Tile.Tile baseTile = (Tile.Tile)Layout[position.Y, position.X];
            Layout[position.Y, position.X] = new ItemTileDecorator(baseTile, item);
        }
        public void RemoveItemAt(Coordinates position)
        {
            var tile = Layout[position.Y, position.X] as ItemTileDecorator;
            if (tile != null)
            {
                Layout[position.Y, position.X] = tile.GetBaseTile();
            }
        }
        public void RegisterDoor(IDoor door)
        {
            if (!_doors.Contains(door))
            {
                _doors.Add(door);
            }
        }
        public IEnumerable<IDoor> GetDoors() => _doors;
    }
}

// File: TempleOfDoom.BusinessLogic\Services\DoorService.cs
namespace TempleOfDoom.BusinessLogic.Services
{
    public class DoorService : IDoorService
    {
        // Check if door in the given direction can be opened
        public bool CanPassThroughDoor(Player player, Room room, Direction direction)
        {
            var doorPos = GetDoorPositionForDirection(room, direction);
            var doorTile = room.GetTileAt(doorPos) as DoorTile;
            if (doorTile == null) return true; // No door tile => passable
            return doorTile.Door.IsOpen(player, room);
        }
        public void AfterPassingDoor(Room room, Direction direction)
        {
            var doorPos = GetDoorPositionForDirection(room, direction);
            var doorTile = room.GetTileAt(doorPos) as DoorTile;
            // If the door is a "closing gate" decorator, then we call NotifyStateChange
            // so it can permanently close after the player passes through.
            if (doorTile != null && ContainsDoorOfType<ClosingGateDoorDecorator>(doorTile.Door))
            {
                doorTile.Door.NotifyStateChange();
            }
        }
        private Coordinates GetDoorPositionForDirection(Room room, Direction direction)
        {
            return direction switch
            {
                Direction.North => new Coordinates(room.Width / 2, 0),
                Direction.South => new Coordinates(room.Width / 2, room.Height - 1),
                Direction.West => new Coordinates(0, room.Height / 2),
                Direction.East => new Coordinates(room.Width - 1, room.Height / 2),
                _ => new Coordinates(1, 1)
            };
        }
        /// <summary>
        /// Recursively checks whether the given door is or contains 
        /// a decorator of type T somewhere in its wrapping chain.
        /// </summary>
        private bool ContainsDoorOfType<T>(IDoor door) where T : IDoor
        {
            // If the current door *is* T, we are done
            if (door is T) return true;
            // If it's a decorator, inspect its wrapped door
            if (door is DoorDecorator decorator)
            {
                return ContainsDoorOfType<T>(decorator.WrappedDoor);
            }
            // If it's neither T nor a decorator, there's nowhere else to look
            return false;
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Services\PlayerMovementController.cs
namespace TempleOfDoom.BusinessLogic.Services
{
    public class PlayerMovementController : IPlayerMovementController
    {
        private readonly IMovementStrategy _movementStrategy;
        private readonly IRoomTransitionService _roomTransitionService;
        private readonly IDoorService _doorService;
        private readonly IItemCollector _itemCollector;
        private readonly IGameStateManager _gameStateManager;
        public PlayerMovementController(
            IMovementStrategy movementStrategy,
            IRoomTransitionService roomTransitionService,
            IDoorService doorService,
            IItemCollector itemCollector,
            IGameStateManager gameStateManager)
        {
            _movementStrategy = movementStrategy;
            _roomTransitionService = roomTransitionService;
            _doorService = doorService;
            _itemCollector = itemCollector;
            _gameStateManager = gameStateManager;
        }
        public bool TryMovePlayer(Player player, Room currentRoom, Direction direction, out Room newCurrentRoom) // CHANGED
        {
            newCurrentRoom = currentRoom; // default to currentRoom
            if (_gameStateManager.IsGameOver) return false;
            Coordinates nextPos = _movementStrategy.GetNextPosition(player, currentRoom, direction);
            if (IsInsideRoom(nextPos, currentRoom))
            {
                // Inside room movement
                if (IsPositionWalkable(currentRoom, player, nextPos))
                {
                    player.UpdatePosition(nextPos);
                    _itemCollector.HandleItemInteraction(player, currentRoom); // may set win/lose
                    return true;
                }
                return false;
            }
            else
            {
                // Attempt room transition
                if (_doorService.CanPassThroughDoor(player, currentRoom, direction))
                {
                    if (_roomTransitionService.TryTransition(currentRoom, player, direction, out var nextRoom))
                    {
                        _itemCollector.HandleItemInteraction(player, nextRoom);
                        newCurrentRoom = nextRoom; // CHANGED: Instead of setting via GameService, return it
                        return true;
                    }
                }
            }
            return false;
        }
        private bool IsInsideRoom(Coordinates pos, Room room)
        {
            return pos.X >= 0 && pos.X < room.Width && pos.Y >= 0 && pos.Y < room.Height;
        }
        private bool IsPositionWalkable(Room room, Player player, Coordinates pos)
        {
            var tile = room.GetTileAt(pos);
            if (tile is DoorTile doorTile)
            {
                return doorTile.Door.IsOpen(player, room);
            }
            return tile.IsWalkable;
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Services\RoomTransitionService.cs
namespace TempleOfDoom.BusinessLogic.Services
{
    public class RoomTransitionService : IRoomTransitionService
    {
        private readonly Dictionary<int, Dictionary<Direction, int>> _roomConnections;
        private readonly IDoorService _doorService;
        private readonly Dictionary<int, Room> _roomsById; 
        public RoomTransitionService(Dictionary<int, Dictionary<Direction, int>> roomConnections, IDoorService doorService, Dictionary<int, Room> roomsById) 
        {
            _roomConnections = roomConnections;
            _doorService = doorService;
            _roomsById = roomsById; 
        }
        public bool TryTransition(Room currentRoom, Player player, Direction direction, out Room nextRoom)
        {
            nextRoom = null;
            if (!_roomConnections.TryGetValue(currentRoom.Id, out var connForRoom))
                return false;
            if (!connForRoom.TryGetValue(direction, out int nextRoomId))
                return false;
            _doorService.AfterPassingDoor(currentRoom, direction);
            nextRoom = GetNextRoom(nextRoomId);
            var entryPos = GetEntryPositionInNextRoom(nextRoom, OppositeDirection(direction));
            player.UpdatePosition(entryPos);
            return true;
        }
        private Room GetNextRoom(int roomId)
        {
            // CHANGED: no longer rely on GameService. Use _roomsById
            return _roomsById[roomId];
        }
        private Coordinates GetEntryPositionInNextRoom(Room nextRoom, Direction comingFromDirection)
        {
            return comingFromDirection switch
            {
                Direction.North => new Coordinates(nextRoom.Width / 2, 0),
                Direction.South => new Coordinates(nextRoom.Width / 2, nextRoom.Height - 1),
                Direction.West => new Coordinates(0, nextRoom.Height / 2),
                Direction.East => new Coordinates(nextRoom.Width - 1, nextRoom.Height / 2),
                _ => new Coordinates(1, 1)
            };
        }
        private Direction OppositeDirection(Direction direction)
        {
            return direction switch
            {
                Direction.North => Direction.South,
                Direction.South => Direction.North,
                Direction.East => Direction.West,
                Direction.West => Direction.East,
                _ => direction
            };
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Strategies\DefaultMovementStrategy.cs
namespace TempleOfDoom.BusinessLogic.Strategies
{
    public class DefaultMovementStrategy : IMovementStrategy
    {
        public Coordinates GetNextPosition(Player player, Room currentRoom, Direction direction)
        {
            Coordinates movement = DirectionHelper.ToCoordinates(direction);
            Coordinates newPosition = player.Position + movement;
            // Boundary checks and collision checks can be done here or delegated
            // to another service if needed.
            return newPosition;
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Structs\Coordinates.cs
namespace TempleOfDoom.BusinessLogic.Struct
{
    public struct Coordinates
    {
        public int X { get; }
        public int Y { get; }
        public Coordinates(int x, int y)
        {
            X = x;
            Y = y;
        }
        // Add useful methods and operators
        public static Coordinates operator +(Coordinates a, Coordinates b)
        {
            return new Coordinates(a.X + b.X, a.Y + b.Y);
        }
        public override string ToString()
        {
            return $"({X}, {Y})";
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Models\Doors\ClosingGateDoorDecorator.cs
namespace TempleOfDoom.BusinessLogic.Models.Doors
{
    public class ClosingGateDoorDecorator : DoorDecorator
    {
        private bool _hasClosed = false;
        public ClosingGateDoorDecorator(IDoor wrappedDoor)
            : base(wrappedDoor)
        {
        }
        public override bool IsOpen(Player player, Room currentRoom)
        {
            // As soon as it's passed once, we close forever
            // It's "open" only if not closed YET and the base chain is also open
            return !_hasClosed && base.IsOpen(player, currentRoom);
        }
        public override char GetRepresentation(bool isHorizontal)
        {
            return _hasClosed ? 'n' : ' ';
        }
        public override ConsoleColor GetColor()
        {
            return _hasClosed ? ConsoleColor.DarkMagenta : ConsoleColor.White;
        }
        public override void NotifyStateChange()
        {
            // after passing the door, we close it
            _hasClosed = true;
            // optionally call base
            base.NotifyStateChange();
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Models\Doors\ColoredDoorDecorator .cs
namespace TempleOfDoom.BusinessLogic.Models.Doors
{
    public class ColoredDoorDecorator : DoorDecorator
    {
        private readonly string _color;
        public ColoredDoorDecorator(IDoor wrappedDoor, string color)
            : base(wrappedDoor)
        {
            _color = color.ToLower();
        }
        public override char GetRepresentation(bool isHorizontal)
        {
            // If you want a certain char for a colored door, override it here
            // or fallback to the base if you only want to color it.
            return isHorizontal ? '=' : '|';
        }
        public override ConsoleColor GetColor()
        {
            // Instead of returning the wrapped door color, we do the color override
            return _color switch
            {
                "red" => ConsoleColor.Red,
                "green" => ConsoleColor.Green,
                _ => ConsoleColor.DarkGray
            };
        }
        public override bool IsOpen(Player player, Room currentRoom)
        {
            // If the player has the matching key, we can allow open
            bool hasMatchingKey = player.Inventory.Any(i => i is KeyItem key && key.Color.ToLower() == _color);
            return hasMatchingKey && base.IsOpen(player, currentRoom);
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Models\Doors\DefaultDoor.cs
namespace TempleOfDoom.BusinessLogic.Models.Doors
{
    public class DefaultDoor : IDoor
    {
        public virtual char GetRepresentation(bool isHorizontal) => ' ';
        public virtual ConsoleColor GetColor() => ConsoleColor.White;
        public virtual bool IsOpen(Player player, Room currentRoom) => true;
        public virtual void NotifyStateChange() { /* no-op */ }
    }
}

// File: TempleOfDoom.BusinessLogic\Models\Doors\OpenOnOddDoorDecorator.cs
namespace TempleOfDoom.BusinessLogic.Models.Doors
{
    public class OpenOnOddDoorDecorator : DoorDecorator
    {
        public OpenOnOddDoorDecorator(IDoor wrappedDoor)
            : base(wrappedDoor)
        { }
        public override char GetRepresentation(bool isHorizontal)
        {
            return base.GetRepresentation(isHorizontal);
        }
        public override ConsoleColor GetColor()
        {
            return base.GetColor();
        }
        public override bool IsOpen(Player player, Room currentRoom)
        {
            // Check base chain *and* the odd-lives condition
            return base.IsOpen(player, currentRoom) && (player.Lives % 2 != 0);
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Models\Doors\OpenOnStonesInRoomDecorator.cs
namespace TempleOfDoom.BusinessLogic.Models.Doors
{
    public class OpenOnStonesInRoomDecorator : DoorDecorator
    {
        private readonly int _requiredStones;
        public OpenOnStonesInRoomDecorator(IDoor wrappedDoor, int requiredStones)
            : base(wrappedDoor)
        {
            _requiredStones = requiredStones;
        }
        public override bool IsOpen(Player player, Room currentRoom)
        {
            // Count the sankara stones in the current room
            int stonesInRoom = 0;
            for (int y = 0; y < currentRoom.Height; y++)
            {
                for (int x = 0; x < currentRoom.Width; x++)
                {
                    var tile = currentRoom.GetTileAt(new Coordinates(x, y));
                    if (tile is ItemTileDecorator itemTile &&
                        itemTile.Item is SankaraStone)
                    {
                        stonesInRoom++;
                    }
                }
            }
            // Door only opens if base door is open AND the exact number of stones matches
            return base.IsOpen(player, currentRoom) && (stonesInRoom == _requiredStones);
        }
        public override char GetRepresentation(bool isHorizontal)
        {
            return base.GetRepresentation(isHorizontal);
        }
        public override ConsoleColor GetColor()
        {
            return base.GetColor();
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Models\Doors\PressurePlateDoor.cs
namespace TempleOfDoom.BusinessLogic.Models.Doors
{
    public class PressurePlateDoor : IDoor
    {
        public char GetRepresentation(bool isHorizontal) => '⊥';
        public ConsoleColor GetColor() => ConsoleColor.Cyan;
        public bool IsOpen(Player player, Room currentRoom)
        {
            // Placeholder: maybe always open for now
            return true;
        }
        public void NotifyStateChange() { /* Not used yet */ }
    }
}

// File: TempleOfDoom.BusinessLogic\Models\Doors\ToggleDoorDecorator.cs
namespace TempleOfDoom.BusinessLogic.Models.Doors
{
    public class ToggleDoorDecorator : DoorDecorator
    {
        private bool _isOpen = false; // default closed
        public ToggleDoorDecorator(IDoor wrappedDoor)
            : base(wrappedDoor)
        { }
        public override char GetRepresentation(bool isHorizontal)
        {
            // special toggle representation
            return '\u22A5'; // or any symbol you like
        }
        public override ConsoleColor GetColor()
        {
            // highlight toggles in yellow, for example
            return ConsoleColor.Yellow;
        }
        public override bool IsOpen(Player player, Room currentRoom)
        {
            // Must also be open in the chain above
            // Return true if BOTH chain is open and _isOpen is true
            return base.IsOpen(player, currentRoom) && _isOpen;
        }
        public override void NotifyStateChange()
        {
            // Flip state
            _isOpen = !_isOpen;
            // We also call base.NotifyStateChange if we want to let the rest 
            // of the chain know, or do something else. 
            base.NotifyStateChange();
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Models\Items\BoobyTrap.cs
namespace TempleOfDoom.BusinessLogic.Models.Item.Item
{
    namespace TempleOfDoom.BusinessLogic.Models.Item.Item
    {
        public class BoobyTrap : IItem
        {
            public int Damage { get; }
            public string Name => "BoobyTrap";
            public bool IsCollectible => false;
            public BoobyTrap(int damage)
            {
                Damage = damage;
            }
            public bool OnPlayerEnter(Player player, Room currentRoom) 
            {
                player.Lives -= Damage;
                return false; 
            }
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Models\Items\DisappearingBoobyTrap.cs
namespace TempleOfDoom.BusinessLogic.Models.Item.Item
{
    public class DisappearingBoobyTrap : IItem
    {
        public int Damage { get; }
        public string Name => "Disappearing BoobyTrap";
        public bool IsCollectible => false;
        public DisappearingBoobyTrap(int damage)
        {
            Damage = damage;
        }
        public bool OnPlayerEnter(Player player, Room currentRoom)
        {
            player.Lives -= Damage;
            return true; 
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Models\Items\Item.cs
namespace TempleOfDoom.BusinessLogic.Models.Items
{
    public class Item
    {
        public Coordinates Position { get; set; }
        public string Type { get; set; }
        public Item(int x, int y, string type)
        {
            Position = new Coordinates(x, y);
            Type = type;
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Models\Items\KeyItem.cs
namespace TempleOfDoom.BusinessLogic.Models.Item.Item
{
    public class KeyItem : IItem
    {
        public string Color { get; }
        public string Name => $"Key({Color})";
        public bool IsCollectible => true;
        public KeyItem(string color)
        {
            Color = color;
        }
        public bool OnPlayerEnter(Player player, Room currentRoom)
        {
            player.CollectItem(this);
            return true; // Remove after collection
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Models\Items\PressurePlate.cs
namespace TempleOfDoom.BusinessLogic.Models.Items
{
    namespace TempleOfDoom.BusinessLogic.Models.Items
    {
        public class PressurePlate : IItem
        {
            public string Name => "Pressure Plate";
            public bool IsCollectible => false;
            public bool OnPlayerEnter(Player player, Room currentRoom) 
            {
                foreach (var door in currentRoom.GetDoors()) 
                {
                    door.NotifyStateChange();
                }
                return false;
            }
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Models\Items\SankaraStone.cs
namespace TempleOfDoom.BusinessLogic.Models.Items
{
    namespace TempleOfDoom.BusinessLogic.Models.Items
    {
        public class SankaraStone : IItem
        {
            public string Name => "Sankara Stone";
            public bool IsCollectible => true;
            public bool OnPlayerEnter(Player player, Room currentRoom)
            {
                player.CollectItem(this);
                return true;
            }
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Models\Tile\DoorTile.cs
namespace TempleOfDoom.BusinessLogic.Models.Tile
{
    public class DoorTile : Tile
    {
        private readonly IDoor _door;
        private readonly bool _isHorizontal;
        // Add a public property to expose the door
        public IDoor Door => _door;
        public DoorTile(IDoor door, bool isHorizontal)
        {
            _door = door;
            _isHorizontal = isHorizontal;
        }
        public override string Representation => _door.GetRepresentation(_isHorizontal).ToString();
        public override bool IsWalkable => false;
        public ConsoleColor GetDoorColor() => _door.GetColor();
    }
}

// File: TempleOfDoom.BusinessLogic\Models\Tile\FloorTile.cs
namespace TempleOfDoom.BusinessLogic.Models.Tile
{
    public class FloorTile : Tile
    {
        public override string Representation => " ";
        public override bool IsWalkable => true;
    }
}

// File: TempleOfDoom.BusinessLogic\Models\Tile\Tile.cs
namespace TempleOfDoom.BusinessLogic.Models.Tile
{
    public abstract class Tile : ITile
    {
        public abstract string Representation { get; }
        public abstract bool IsWalkable { get; }
    }
}

// File: TempleOfDoom.BusinessLogic\Models\Tile\WallTile.cs
namespace TempleOfDoom.BusinessLogic.Models.Tile
{
    public class WallTile : Tile
    {
        public override string Representation => "#";
        public override bool IsWalkable => false;
    }
}

// File: TempleOfDoom.DataAccess\ConnectionDto.cs
namespace TempleOfDoom.DataAccess
{
    public class ConnectionDto
    {
        public int? NORTH { get; set; }
        public int? SOUTH { get; set; }
        public int? EAST { get; set; }
        public int? WEST { get; set; }
        public List<DoorDto> Doors { get; set; }
    }
}

// File: TempleOfDoom.DataAccess\DoorDto.cs
namespace TempleOfDoom.DataAccess
{
    public class DoorDto
    {
        public string Type { get; set; }
        public string Color { get; set; } // Nullable for optional properties
        public int? NoOfStones { get; set; } // Nullable for optional properties
    }
}

// File: TempleOfDoom.DataAccess\ItemDto.cs
namespace TempleOfDoom.DataAccess
{
    public class ItemDto
    {
        public string Type { get; set; }
        public int? Damage { get; set; } // Nullable for optional properties
        public string Color { get; set; } // Nullable for optional properties
        public int X { get; set; }
        public int Y { get; set; }
    }
}

// File: TempleOfDoom.DataAccess\JsonLevelLoader.cs
namespace TempleOfDoom.DataAccess
{
    public class JsonLevelLoader
    {
        public LevelDto LoadLevel(string filePath)
        {
            if (!File.Exists(filePath))
            {
                throw new FileNotFoundException("JSON file not found.", filePath);
            }
            string jsonContent = File.ReadAllText(filePath);
            // Configure deserialization options
            JsonSerializerOptions options = new JsonSerializerOptions
            {
                PropertyNameCaseInsensitive = true // Makes JSON property names case-insensitive
            };
            LevelDto levelData = JsonSerializer.Deserialize<LevelDto>(jsonContent, options);
            return levelData;
        }
    }
}

// File: TempleOfDoom.DataAccess\LevelDto.cs
namespace TempleOfDoom.DataAccess
{
    public class LevelDto
    {
        public List<RoomDto> Rooms { get; set; }
        public List<ConnectionDto> Connections { get; set; }
        public PlayerDto Player { get; set; }
    }
}

// File: TempleOfDoom.DataAccess\PlayerDto.cs
namespace TempleOfDoom.DataAccess
{
    public class PlayerDto
    {
        public int StartRoomId { get; set; }
        public int StartX { get; set; }
        public int StartY { get; set; }
        public int Lives { get; set; }
    }
}

// File: TempleOfDoom.DataAccess\RoomDto.cs
namespace TempleOfDoom.DataAccess
{
    public class RoomDto
    {
        public int Id { get; set; }
        public string Type { get; set; }
        public int Width { get; set; }
        public int Height { get; set; }
        public List<ItemDto> Items { get; set; }
    }
}

