// Consolidated Code Extracted on 11-1-2025 17:23:10

// File: TempleOfDoom.Presentation\ColorManager.cs
namespace TempleOfDoom.Presentation
{
    public static class ColorManager
    {
        // If you want, these could be loaded from a config file or a JSON in the future.
        // Default colors
        private static readonly ConsoleColor DefaultTileColor = ConsoleColor.White;
        private static readonly ConsoleColor DefaultItemColor = ConsoleColor.White;
        private static readonly ConsoleColor PlayerColor = ConsoleColor.Blue; // Example for the player
        // Dictionaries for quick lookups
        private static Dictionary<string, ConsoleColor> tileColors = new Dictionary<string, ConsoleColor>
        {
            // Map tile type names to colors
            { nameof(WallTile), ConsoleColor.Yellow },
            { nameof(FloorTile), ConsoleColor.Gray },
            { nameof(DoorTile), ConsoleColor.DarkGray }
            // Add more tile types here in the future
        };
        private static Dictionary<string, ConsoleColor> itemColors = new Dictionary<string, ConsoleColor>
        {
            // Map item "type" names or known names to colors
            // We'll handle keys separately since they contain their color in the name.
            { "Sankara Stone", ConsoleColor.DarkYellow }, // approximation for "orange"
            { "BoobyTrap", ConsoleColor.DarkRed },
            { "Disappearing BoobyTrap", ConsoleColor.Red },
            { "Pressure Plate", ConsoleColor.Cyan }
            // Keys will be handled dynamically
        };
        public static ConsoleColor GetColorForTile(ITile tile)
        {
            string tileTypeName = tile.GetType().Name;
            if (tileColors.ContainsKey(tileTypeName))
            {
                return tileColors[tileTypeName];
            }
            return DefaultTileColor;
        }
        public static ConsoleColor GetColorForItem(IItem item)
        {
            // Keys have color embedded in their name, e.g. "Key(green)", "Key(red)"
            if (item.Name.StartsWith("Key("))
            {
                return GetKeyColor(item.Name);
            }
            if (itemColors.ContainsKey(item.Name))
            {
                return itemColors[item.Name];
            }
            return DefaultItemColor;
        }
        public static ConsoleColor GetColorForPlayer()
        {
            return PlayerColor;
        }
        private static ConsoleColor GetKeyColor(string keyName)
        {
            // keyName format: "Key(color)"
            // Extract the color from between parentheses
            int start = keyName.IndexOf('(') + 1;
            int end = keyName.IndexOf(')');
            if (start > 0 && end > start)
            {
                string colorStr = keyName.Substring(start, end - start).ToLower();
                return colorStr switch
                {
                    "red" => ConsoleColor.Red,
                    "green" => ConsoleColor.Green,
                    "blue" => ConsoleColor.Blue, // If you ever have a blue key
                    _ => DefaultItemColor
                };
            }
            return DefaultItemColor;
        }
    }
}

// File: TempleOfDoom.Presentation\InputHandler.cs
namespace TempleOfDoom.Presentation
{
    public static class InputHandler
    {
        public static Direction? GetDirectionFromInput(ConsoleKey key)
        {
            return key switch
            {
                ConsoleKey.UpArrow or ConsoleKey.W => Direction.North,
                ConsoleKey.DownArrow or ConsoleKey.S => Direction.South,
                ConsoleKey.LeftArrow or ConsoleKey.A => Direction.West,
                ConsoleKey.RightArrow or ConsoleKey.D => Direction.East,
                _ => null
            };
        }
    }
}

// File: TempleOfDoom.Presentation\Program.cs
namespace TempleOfDoom.Presentation
{
    public class Program
    {
        private static bool StartGame = false;
        public static void Main(string[] args)
        {
            if (StartGame)
            {
                Console.OutputEncoding = System.Text.Encoding.UTF8;
                string filePath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Resources", "TempleOfDoom_Extended_A_2122.json");
                JsonLevelLoader loader = new JsonLevelLoader();
                LevelDto levelData = loader.LoadLevel(filePath);
                IItemFactory itemFactory = new DefaultItemFactory();
                Dictionary<int, Room> roomsById = new Dictionary<int, Room>();
                foreach (var roomDto in levelData.Rooms)
                {
                    Room room = LevelMapper.MapRoomDtoToRoom(roomDto, itemFactory);
                    roomsById[room.Id] = room;
                }
                LevelMapper.ApplyConnectionsToRooms(levelData.Connections, roomsById);
                var roomConnections = LevelMapper.CreateRoomConnectionMap(levelData.Connections);
                IGameStateManager gameStateManager = new GameStateManager();
                Player player = LevelMapper.MapPlayerDtoToPlayer(levelData.Player, gameStateManager);
                Room currentRoom = roomsById[levelData.Player.StartRoomId];
                // Pass the SAME gameStateManager into the GameService constructor
                GameService gameService = new GameService(
                    gameStateManager,
                    currentRoom,
                    player,
                    roomsById,
                    roomConnections
                );
                Console.OutputEncoding = System.Text.Encoding.UTF8;
                bool isRunning = true;
                while (isRunning)
                {
                    if (gameService.IsGameOver)
                    {
                        // Game ended (win or lose)
                        Console.Clear();
                        if (gameService.IsWin)
                        {
                            Renderer.RenderWinScreen();
                        }
                        else if (gameService.IsLose)
                        {
                            Renderer.RenderLoseScreen();
                        }
                        break;
                    }
                    Console.Clear();
                    Renderer.RenderRoom(gameService.CurrentRoom, gameService.Player);
                    Renderer.RenderPlayerStatus(gameService.Player, gameService.CurrentRoom);
                    ConsoleKeyInfo keyInfo = Console.ReadKey(true);
                    Direction? direction = InputHandler.GetDirectionFromInput(keyInfo.Key);
                    if (direction.HasValue)
                    {
                        gameService.HandlePlayerMovement(direction.Value);
                    }
                    else if (keyInfo.Key == ConsoleKey.Escape)
                    {
                        isRunning = false;
                    }
                }
                // Wait for a key press before closing
                Console.WriteLine("Press any key to exit...");
                Console.ReadKey(true);
            }
            else
            {
                ExtractAndOpenCode();
            }
        }
        private static void ExtractAndOpenCode()
        {
            // Define the project root path. Adjust this path as needed to get to the solution folder
            string projectRootPath = Path.GetFullPath(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "..", "..", "..", ".."));
            // Define the output file path. For example, place it in a "Output" folder within the project directory.
            string outputFilePath = Path.Combine(projectRootPath, "current_code.txt");
            // Use the CodeExtractor class to perform the extraction
            string[] includedDirectories = new string[] { "TempleOfDoom.Presentation", "TempleOfDoom.BusinessLogic", "TempleOfDoom.DataAccess" };
            CodeExtractor.ExtractCodeToTxt(projectRootPath, outputFilePath, includedDirectories);
            // Use the FileOpener class to open the output file
            FileOpener.OpenFile(outputFilePath);
        }
    }
}

// File: TempleOfDoom.Presentation\Renderer.cs
namespace TempleOfDoom.Presentation
{
    public static class Renderer
    {
        public static void RenderRoom(Room room, Player player)
        {
            // Pre-fetch enemy positions to avoid repeating LINQ calls
            var enemyPositions = room.GetEnemyPositions().ToList();
            for (int y = 0; y < room.Height; y++)
            {
                for (int x = 0; x < room.Width; x++)
                {
                    Coordinates coords = new Coordinates(x, y);
                    // 1) Check if it's the player
                    if (coords.Equals(player.Position))
                    {
                        Console.ForegroundColor = ColorManager.GetColorForPlayer();
                        Console.Write("X ");
                        Console.ResetColor();
                        continue;
                    }
                    // 2) Check if an enemy is here
                    bool isEnemyHere = enemyPositions.Any(pos => pos.X == x && pos.Y == y);
                    if (isEnemyHere)
                    {
                        // We don't care *what type* of enemy—just print 'E'
                        Console.ForegroundColor = ConsoleColor.Red;
                        Console.Write("E ");
                        Console.ResetColor();
                        continue;
                    }
                    // 3. Tile rendering
                    var tile = room.GetTileAt(coords);
                    if (tile is DoorTile doorTile)
                    {
                        var doorColor = doorTile.GetDoorColor();
                        Console.ForegroundColor = doorColor;
                        Console.Write($"{doorTile.Representation} ");
                        Console.ResetColor();
                    }
                    else if (tile is FloorTile floorTile)
                    {
                        if (floorTile.Item != null)
                        {
                            Console.ForegroundColor = ColorManager.GetColorForItem(floorTile.Item);
                            Console.Write($"{floorTile.Item.Representation} ");
                            Console.ResetColor();
                        }
                        else
                        {
                            Console.ForegroundColor = ColorManager.GetColorForTile(floorTile);
                            Console.Write($"{floorTile.Representation} ");
                            Console.ResetColor();
                        }
                    }
                    else
                    {
                        // WallTile or other types
                        Console.ForegroundColor = ColorManager.GetColorForTile(tile);
                        Console.Write($"{tile.Representation} ");
                        Console.ResetColor();
                    }
                }
                Console.WriteLine();
            }
        }
        public static void RenderPlayerStatus(Player player, Room currentRoom)
        {
            Console.WriteLine();
            Console.WriteLine($"Current Room: {currentRoom.Id}");
            Console.WriteLine($"Lives: {player.Lives}");
            Console.Write("Inventory: ");
            if (player.Inventory.Count == 0)
            {
                Console.WriteLine("Empty");
            }
            else
            {
                foreach (var item in player.Inventory)
                {
                    Console.ForegroundColor = ColorManager.GetColorForItem(item);
                    Console.Write($"{item.Name}, ");
                    Console.ResetColor();
                }
                Console.WriteLine();
            }
        }
        public static void RenderWinScreen()
        {
            Console.ForegroundColor = ConsoleColor.Green;
            Console.WriteLine("****************************************************");
            Console.WriteLine("                   YOU WIN!                         ");
            Console.WriteLine("You have collected all the Sankara Stones!          ");
            Console.WriteLine("****************************************************");
            Console.ResetColor();
        }
        public static void RenderLoseScreen()
        {
            Console.ForegroundColor = ConsoleColor.Red;
            Console.WriteLine("****************************************************");
            Console.WriteLine("                   YOU LOSE!                        ");
            Console.WriteLine("You ran out of lives. Better luck next time.        ");
            Console.WriteLine("****************************************************");
            Console.ResetColor();
        }
    }
}

// File: TempleOfDoom.Presentation\RemoveLater\CodeExtractor.cs
namespace TempleOfDoom.BusinessLogic
{
    public static class CodeExtractor
    {
        /// <summary>
        /// Extracts code from the specified directories and consolidates it into a single text file.
        /// </summary>
        /// <param name="projectRootPath">The root path of the project.</param>
        /// <param name="outputFilePath">The output file path where the consolidated code will be saved.</param>
        /// <param name="includedDirectories">An array of directories to include in the extraction.</param>
        public static void ExtractCodeToTxt(string projectRootPath, string outputFilePath, string[] includedDirectories)
        {
            try
            {
                // Ensure the output directory exists
                string outputDirectory = Path.GetDirectoryName(outputFilePath);
                if (!Directory.Exists(outputDirectory))
                {
                    Directory.CreateDirectory(outputDirectory);
                    Console.WriteLine($"Created output directory: {outputDirectory}");
                }
                // Initialize or clear the output file and write the header
                {
                    writer.WriteLine("// Consolidated Code Extracted on " + DateTime.Now);
                    writer.WriteLine();
                }
                // Define directories to exclude
                var excludedDirectories = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
                {
                    "bin",
                    "obj",
                    ".git",
                    ".vs",
                    "Properties",
                    "Resources" // Add other directories as needed
                };
                // Retrieve all .cs files from the specified included directories
                var csFiles = includedDirectories.SelectMany(dir => Directory.GetFiles(Path.Combine(projectRootPath, dir), "*.cs", SearchOption.AllDirectories))
                    .Where(file => !excludedDirectories.Any(exDir =>
                        Path.GetFullPath(file)
                            .Split(Path.DirectorySeparatorChar)
                            .Contains(exDir, StringComparer.OrdinalIgnoreCase)));
                if (!csFiles.Any())
                {
                    Console.WriteLine("No .cs files found in the specified directories.");
                    return;
                }
                Console.WriteLine($"Found {csFiles.Count()} .cs files. Processing...");
                foreach (var file in csFiles)
                {
                    try
                    {
                        // Read all lines from the current file
                        var lines = File.ReadAllLines(file);
                        // Filter out 'using' directives
                        var filteredLines = lines.Where(line => !Regex.IsMatch(line.Trim(), @"^using\s+")).ToList();
                        // Optionally, remove empty lines for cleaner output
                        filteredLines = filteredLines.Where(line => !string.IsNullOrWhiteSpace(line)).ToList();
                        // Prepare content to append
                        var header = $"// File: {Path.GetRelativePath(projectRootPath, file)}";
                        var content = string.Join(Environment.NewLine, filteredLines);
                        // Append to the output file
                        {
                            writer.WriteLine(header);
                            writer.WriteLine(content);
                            writer.WriteLine(); // Add a newline for separation
                        }
                        Console.WriteLine($"Processed: {Path.GetRelativePath(projectRootPath, file)}");
                    }
                    catch (Exception exFile)
                    {
                        Console.WriteLine($"Error processing file {file}: {exFile.Message}");
                    }
                }
                Console.WriteLine($"Extraction complete. Check the '{outputFilePath}' file.");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"An error occurred during extraction: {ex.Message}");
            }
        }
    }
}

// File: TempleOfDoom.Presentation\RemoveLater\FileOpener.cs
namespace TempleOfDoom.Presentation.RemoveLater
{
    public static class FileOpener
    {
        /// <summary>
        /// Opens the specified file in the default application.
        /// </summary>
        /// <param name="filePath">The full path to the file to open.</param>
        public static void OpenFile(string filePath)
        {
            try
            {
                Console.WriteLine($"Attempting to open file: {filePath}");
                System.Diagnostics.Process.Start(new System.Diagnostics.ProcessStartInfo()
                {
                    FileName = filePath,
                    UseShellExecute = true
                });
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Failed to open the file: {ex.Message}");
            }
        }
    }
}

// File: TempleOfDoom.BusinessLogic\GameService.cs
namespace TempleOfDoom.BusinessLogic
{
    public class GameService
    {
        private Dictionary<int, Room> _roomsById;
        private IGameStateManager _gameStateManager;
        private IPlayerMovementController _playerMovementController;
        public Room CurrentRoom { get; private set; }
        public Player Player { get; private set; }
        public bool IsWin => _gameStateManager.IsWin;
        public bool IsLose => _gameStateManager.IsLose;
        public bool IsGameOver => _gameStateManager.IsGameOver;
        public GameService(
            IGameStateManager gameStateManager,
            Room currentRoom,
            Player player,
            Dictionary<int, Room> roomsById,
            Dictionary<int, Dictionary<Direction, int>> roomConnections)
        {
            _gameStateManager = gameStateManager;
            _roomsById = roomsById;
            int totalStones = CountAllSankaraStones(_roomsById.Values);
            _gameStateManager.SetTotalStones(totalStones);
            IDoorService doorService = new DoorService();
            IRoomTransitionService roomTransitionService =
                new RoomTransitionService(roomConnections, doorService, _roomsById);
            IMovementStrategy movementStrategy = new DefaultMovementStrategy();
            _playerMovementController = new PlayerMovementController(
                movementStrategy,
                roomTransitionService,
                doorService,
                _gameStateManager
            );
            CurrentRoom = currentRoom;
            Player = player;
        }
        public void HandlePlayerMovement(Direction direction)
        {
            if (IsGameOver) return;
            // 1. Move the player
            if (_playerMovementController.TryMovePlayer(Player, CurrentRoom, direction, out var newRoom))
            {
                if (newRoom != CurrentRoom)
                {
                    SetCurrentRoom(newRoom);
                }
            }
            // 2. Now move enemies in the current room
            MoveEnemiesInRoom(CurrentRoom);
            // 3. (Optional) Check if the player has collided with an enemy, etc.
            //    For example, if your design says "if you step on an enemy, you take damage"
            //    you'd do it here. Or you might handle that in the Move() logic, up to you.
        }
        private void MoveEnemiesInRoom(Room room)
        {
            // Snapshot the list in case enemies die mid-loop
            var enemiesSnapshot = room.Enemies.ToList();
            foreach (var enemy in enemiesSnapshot)
            {
                if (room.Enemies.Contains(enemy))
                {
                    enemy.Move();  // The big moment:
                                   // This calls IField.Move() → moves to neighbor.
                                   // Because we set CurrentField, everything should line up.
                }
            }
        }
        public void SetCurrentRoom(Room room)
        {
            CurrentRoom = room;
        }
        private int CountAllSankaraStones(IEnumerable<Room> rooms)
        {
            int count = 0;
            foreach (var room in rooms)
            {
                for (int y = 0; y < room.Height; y++)
                {
                    for (int x = 0; x < room.Width; x++)
                    {
                        if (room.Layout[y, x] is FloorTile floorTile
                            && floorTile.Item is SankaraStoneDecorator)
                        {
                            count++;
                        }
                    }
                }
            }
            return count;
        }
        public IEnumerable<(int X, int Y)> GetEnemyPositions(Room room)
        {
            // We can see the real library's Enemy here because BusinessLogic references it.
            return room.Enemies.Select(e => (e.CurrentXLocation, e.CurrentYLocation));
        }
    }
}

// File: TempleOfDoom.BusinessLogic\LevelMapper.cs
namespace TempleOfDoom.BusinessLogic.Mappers
{
    public static class LevelMapper
    {
        public static Room MapRoomDtoToRoom(RoomDto roomDto, IItemFactory itemFactory)
        {
            var room = new Room(roomDto.Width, roomDto.Height)
            {
                Id = roomDto.Id,
                Type = roomDto.Type
            };
            room.GenerateLayout();
            // Place items
            if (roomDto.Items != null)
            {
                foreach (var itemDto in roomDto.Items)
                {
                    var item = itemFactory.CreateItem(itemDto);
                    room.PlaceItem(new Coordinates(itemDto.X, itemDto.Y), item);
                }
            }
            // Create real Enemy objects from the DLL
            if (roomDto.Enemies != null)
            {
                foreach (var enemyDto in roomDto.Enemies)
                {
                    Enemy enemy = CreateEnemyFromDto(enemyDto);
                    // Set the correct FieldAdapter
                    enemy.CurrentField = room.FieldAdapters[enemyDto.Y, enemyDto.X];
                    room.FieldAdapters[enemyDto.Y, enemyDto.X].Item = enemy;
                    // Subscribe to OnDeath event
                    enemy.OnDeath += (sender, e) =>
                    {
                        room.Enemies.Remove(enemy);
                        // If the enemy’s field is still pointing to this enemy, clear it
                        if (enemy.CurrentField != null)
                        {
                            enemy.CurrentField.Item = null;
                        }
                    };
                    room.Enemies.Add(enemy);
                }
            }
            return room;
        }
        private static Enemy CreateEnemyFromDto(EnemyDto dto)
        {
            // For example, all enemies get 3 lives by default (or read from JSON).
            int initialLives = 1;
            switch (dto.Type.ToLower())
            {
                case "horizontal":
                    return new HorizontallyMovingEnemy(
                        initialLives,
                        dto.X,
                        dto.Y,
                        dto.MinX,
                        dto.MaxX
                    );
                case "vertical":
                    return new VerticallyMovingEnemy(
                        initialLives,
                        dto.X,
                        dto.Y,
                        dto.MinY,
                        dto.MaxY
                    );
                default:
                    throw new ArgumentException($"Unknown enemy type: {dto.Type}");
            }
        }
        public static Player MapPlayerDtoToPlayer(PlayerDto playerDto, IGameStateManager gameStateManager)
        {
            return new Player(playerDto.StartX, playerDto.StartY, playerDto.Lives, gameStateManager);
        }
        public static void ApplyConnectionsToRooms(List<ConnectionDto> connections, Dictionary<int, Room> rooms)
        {
            foreach (var connection in connections)
            {
                // Apply to north/south
                if (connection.NORTH.HasValue && connection.SOUTH.HasValue)
                {
                    IDoor door = DoorFactory.CreateCompositeDoor(connection.Doors);
                    CreateDoorTileForRoom(rooms[connection.NORTH.Value], Direction.South, door);
                    CreateDoorTileForRoom(rooms[connection.SOUTH.Value], Direction.North, door);
                }
                // East/West
                if (connection.EAST.HasValue && connection.WEST.HasValue)
                {
                    IDoor door = DoorFactory.CreateCompositeDoor(connection.Doors);
                    CreateDoorTileForRoom(rooms[connection.EAST.Value], Direction.West, door);
                    CreateDoorTileForRoom(rooms[connection.WEST.Value], Direction.East, door);
                }
                // If in part 2 you have UPPER/LOWER or portals, you'd handle them here similarly.
            }
        }
        private static void CreateDoorTileForRoom(Room room, Direction direction, IDoor door)
        {
            bool isHorizontal = (direction == Direction.North || direction == Direction.South);
            Coordinates doorPosition = GetDoorPosition(room, direction);
            room.Layout[doorPosition.Y, doorPosition.X] = new DoorTile(door, isHorizontal);
            // Register if needed
            if (door is ToggleDoorDecorator || door is DoorDecorator)
            {
                room.RegisterDoor(door);
            }
        }
        private static Coordinates GetDoorPosition(Room room, Direction direction)
        {
            int doorX = 0, doorY = 0;
            switch (direction)
            {
                case Direction.North: doorX = room.Width / 2; doorY = 0; break;
                case Direction.South: doorX = room.Width / 2; doorY = room.Height - 1; break;
                case Direction.West: doorX = 0; doorY = room.Height / 2; break;
                case Direction.East: doorX = room.Width - 1; doorY = room.Height / 2; break;
            }
            return new Coordinates(doorX, doorY);
        }
        public static Dictionary<int, Dictionary<Direction, int>> CreateRoomConnectionMap(List<ConnectionDto> connections)
        {
            var map = new Dictionary<int, Dictionary<Direction, int>>();
            foreach (var conn in connections)
            {
                if (conn.NORTH.HasValue && conn.SOUTH.HasValue)
                {
                    AddConnection(map, conn.NORTH.Value, Direction.South, conn.SOUTH.Value);
                    AddConnection(map, conn.SOUTH.Value, Direction.North, conn.NORTH.Value);
                }
                if (conn.EAST.HasValue && conn.WEST.HasValue)
                {
                    AddConnection(map, conn.EAST.Value, Direction.West, conn.WEST.Value);
                    AddConnection(map, conn.WEST.Value, Direction.East, conn.EAST.Value);
                }
            }
            return map;
        }
        private static void AddConnection(Dictionary<int, Dictionary<Direction, int>> map, int fromRoomId, Direction dir, int toRoomId)
        {
            if (!map.ContainsKey(fromRoomId))
                map[fromRoomId] = new Dictionary<Direction, int>();
            map[fromRoomId][dir] = toRoomId;
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Adapters\FieldAdapter.cs
namespace TempleOfDoom.BusinessLogic.Adapters
{
    public class FieldAdapter : IField
    {
        private readonly Room _room;
        private readonly int _x;
        private readonly int _y;
        public bool CanEnter => IsFloorOrOpenDoor();
        // The DLL expects this to get/set the occupant (an Enemy or null).
        // If an enemy moves onto this tile, .Item = that enemy.
        public IPlacable Item { get; set; }
        public FieldAdapter(Room room, int x, int y)
        {
            _room = room;
            _x = x;
            _y = y;
        }
        /// <summary>
        /// direction: 0 (north), 1 (east), 2 (south), 3 (west).
        /// </summary>
        public IField GetNeighbour(int direction)
        {
            int dx = 0, dy = 0;
            switch (direction)
            {
                case 0: dy = -1; break; // north
                case 1: dx = +1; break; // east
                case 2: dy = +1; break; // south
                case 3: dx = -1; break; // west
            }
            int nx = _x + dx;
            int ny = _y + dy;
            // Check room bounds
            if (nx < 0 || ny < 0 || nx >= _room.Width || ny >= _room.Height)
            {
                return null;
            }
            // Return the neighbor's adapter
            return _room.FieldAdapters[ny, nx];
        }
        private bool IsFloorOrOpenDoor()
        {
            var tile = _room.GetTileAt(new Coordinates(_x, _y));
            // If it's a FloorTile => passable
            if (tile is FloorTile) return true;
            // If it's a DoorTile => you can decide whether enemies can pass if the door is open
            if (tile is DoorTile doorTile)
            {
                // By default, let's say enemies cannot pass closed doors:
                // If you want enemies to be blocked by doors, return doorTile.Door.IsOpen(...) 
                // But you might not have a "player" to pass. 
                // We’ll assume “always blocked” for simplicity:
                return false;
            }
            // If it's a WallTile or anything else => not passable
            return false;
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Decorators\DoorDecorator.cs
namespace TempleOfDoom.BusinessLogic.Decorators
{
    public abstract class DoorDecorator : IDoor
    {
        protected readonly IDoor _wrappedDoor;
        protected DoorDecorator(IDoor wrappedDoor)
        {
            _wrappedDoor = wrappedDoor;
        }
        // Public property to access the wrapped door
        public IDoor WrappedDoor => _wrappedDoor;
        public virtual char GetRepresentation(bool isHorizontal)
        {
            return _wrappedDoor.GetRepresentation(isHorizontal);
        }
        public virtual ConsoleColor GetColor()
        {
            return _wrappedDoor.GetColor();
        }
        public virtual bool IsOpen(Player player, Room currentRoom)
        {
            return _wrappedDoor.IsOpen(player, currentRoom);
        }
        public virtual void NotifyStateChange()
        {
            _wrappedDoor.NotifyStateChange();
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Decorators\ItemDecorator.cs
namespace TempleOfDoom.BusinessLogic.Decorators
{
    public abstract class ItemDecorator : IItem
    {
        protected IItem _wrappedItem;
        protected ItemDecorator(IItem wrappedItem)
        {
            _wrappedItem = wrappedItem;
        }
        public virtual string Name => _wrappedItem.Name;
        public virtual string Representation => _wrappedItem.Representation;
        public virtual bool IsCollectible => _wrappedItem.IsCollectible;
        public virtual bool OnPlayerEnter(Player player, Room currentRoom)
        {
            // By default, just delegate to the wrapped item
            return _wrappedItem.OnPlayerEnter(player, currentRoom);
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Enum\Direction.cs
namespace TempleOfDoom.BusinessLogic.Enum
{
    public enum Direction
    {
        North,
        South,
        East,
        West
    }
}

// File: TempleOfDoom.BusinessLogic\Factories\DefaultItemFactory.cs
namespace TempleOfDoom.BusinessLogic.Factories
{
    public class DefaultItemFactory : IItemFactory
    {
        public IItem CreateItem(ItemDto itemDto)
        {
            // Start with an empty base item
            IItem baseItem = new BaseItem();
            switch (itemDto.Type.ToLower())
            {
                case "boobytrap":
                    return new BoobyTrapDecorator(baseItem, itemDto.Damage ?? 1);
                case "disappearing boobytrap":
                    // single class that does both damage + disappearing
                    return new DisappearingBoobyTrapDecorator(baseItem, itemDto.Damage ?? 1);
                case "key":
                    return new KeyDecorator(baseItem, itemDto.Color);
                case "sankara stone":
                    return new SankaraStoneDecorator(baseItem);
                case "pressure plate":
                    return new PressurePlateDecorator(baseItem);
                default:
                    throw new ArgumentException($"Unknown item type: {itemDto.Type}");
            }
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Factories\DoorFactory.cs
namespace TempleOfDoom.BusinessLogic.Factories
{
    public static class DoorFactory
    {
        public static IDoor CreateCompositeDoor(List<DoorDto> doorDtos)
        {
            // If no door info, return a bare door
            if (doorDtos == null || doorDtos.Count == 0)
            {
                return new DefaultDoor();
            }
            // Start with the "plain" door
            IDoor doorChain = new DefaultDoor();
            // Decorate for each door type
            foreach (var dto in doorDtos)
            {
                doorChain = WrapDoor(doorChain, dto);
            }
            return doorChain;
        }
        private static IDoor WrapDoor(IDoor baseDoor, DoorDto doorDto)
        {
            switch (doorDto.Type.ToLower())
            {
                case "colored":
                    return new ColoredDoorDecorator(baseDoor, doorDto.Color);
                case "toggle":
                    return new ToggleDoorDecorator(baseDoor);
                case "closing gate":
                    return new ClosingGateDoorDecorator(baseDoor);
                case "open on odd":
                    return new OpenOnOddDoorDecorator(baseDoor);
                case "open on stones in room":
                    return new OpenOnStonesInRoomDecorator(baseDoor, doorDto.NoOfStones ?? 0);
                // If some unknown type, just return baseDoor or optionally throw
                default:
                    return baseDoor;
            }
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Helpers\DirectionHelper.cs
namespace TempleOfDoom.BusinessLogic.Helpers
{
    public static class DirectionHelper
    {
        public static Coordinates ToCoordinates(Direction direction)
        {
            return direction switch
            {
                Direction.North => new Coordinates(0, -1),
                Direction.South => new Coordinates(0, 1),
                Direction.West => new Coordinates(-1, 0),
                Direction.East => new Coordinates(1, 0),
                _ => new Coordinates(0, 0)
            };
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Interfaces\IDoor.cs
namespace TempleOfDoom.BusinessLogic.Interfaces
{
    public interface IDoor
    {
        char GetRepresentation(bool isHorizontal);
        ConsoleColor GetColor();
        bool IsOpen(Player player, Room currentRoom);
        // Some doors might need to be toggled externally (e.g., pressure plates)
        void NotifyStateChange();
    }
}

// File: TempleOfDoom.BusinessLogic\Interfaces\IDoorService.cs
namespace TempleOfDoom.BusinessLogic.Interfaces
{
    public interface IDoorService
    {
        bool CanPassThroughDoor(Player player, Room room, Direction direction);
        void AfterPassingDoor(Room room, Direction direction);
    }
}

// File: TempleOfDoom.BusinessLogic\Interfaces\IGameStateManager.cs
namespace TempleOfDoom.BusinessLogic.Interfaces
{
    public interface IGameStateManager
    {
        bool IsWin { get; }
        bool IsLose { get; }
        bool IsGameOver { get; }
        void MarkWin();
        void MarkLose();
        // Possibly notify about life changes, stone count changes, etc.
        void SetTotalStones(int total);
        void OnSankaraStoneCollected();
    }
}

// File: TempleOfDoom.BusinessLogic\Interfaces\IItem.cs
namespace TempleOfDoom.BusinessLogic.Interfaces
{
    public interface IItem
    {
        string Name { get; }
        string Representation { get; }     // Let each item or decorator define how it looks
        bool IsCollectible { get; }
        bool OnPlayerEnter(Player player, Room currentRoom);
    }
}

// File: TempleOfDoom.BusinessLogic\Interfaces\IItemFactory.cs
namespace TempleOfDoom.BusinessLogic.Interfaces
{
    public interface IItemFactory
    {
        IItem CreateItem(ItemDto itemDto);
    }
}

// File: TempleOfDoom.BusinessLogic\Interfaces\IMovementStrategy.cs
namespace TempleOfDoom.BusinessLogic.Interfaces
{
    public interface IMovementStrategy
    {
        /// <summary>
        /// Calculates the next position for the player given a direction.
        /// </summary>
        Coordinates GetNextPosition(Player player, Room currentRoom, Direction direction);
    }
}

// File: TempleOfDoom.BusinessLogic\Interfaces\IPlayerMovementController.cs
namespace TempleOfDoom.BusinessLogic.Interfaces
{
    public interface IPlayerMovementController
    {
        /// <summary>
        /// Attempt to move the player in the given direction inside the current room.
        /// Returns true if moved or transitioned, false otherwise.
        /// If room transition occurs, the new room is returned in newCurrentRoom.
        /// </summary>
        bool TryMovePlayer(Player player, Room currentRoom, Direction direction, out Room newCurrentRoom);
    }
}

// File: TempleOfDoom.BusinessLogic\Interfaces\IRenderableEnemy.cs
namespace TempleOfDoom.BusinessLogic.Interfaces
{
    internal class IRenderableEnemy
    {
    }
}

// File: TempleOfDoom.BusinessLogic\Interfaces\IRoomTransitionService.cs
namespace TempleOfDoom.BusinessLogic.Interfaces
{
    public interface IRoomTransitionService
    {
        bool TryTransition(Room currentRoom, Player player, Direction direction, out Room nextRoom);
    }
}

// File: TempleOfDoom.BusinessLogic\Interfaces\ITile.cs
namespace TempleOfDoom.BusinessLogic.Interfaces
{
    public interface ITile
    {
        string Representation { get; }
        bool IsWalkable { get; }
    }
}

// File: TempleOfDoom.BusinessLogic\Manager\GameStateManager.cs
namespace TempleOfDoom.BusinessLogic.Manager
{
    public class GameStateManager : IGameStateManager
    {
        public bool IsWin { get; private set; }
        public bool IsLose { get; private set; }
        public bool IsGameOver => IsWin || IsLose;
        private int _totalStones;
        private int _collectedStones;
        public void MarkWin() => IsWin = true;
        public void MarkLose() => IsLose = true;
        // NEW: Called by GameService (or wherever you prefer) to initialize the total stones
        public void SetTotalStones(int total)
        {
            _totalStones = total;
            _collectedStones = 0;
        }
        // NEW: Called whenever the player picks up a Sankara Stone
        public void OnSankaraStoneCollected()
        {
            _collectedStones++;
            if (_collectedStones >= _totalStones)
            {
                MarkWin();
            }
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Models\Player.cs
namespace TempleOfDoom.BusinessLogic.Models
{
    public class Player
    {
        public Coordinates Position { get; private set; }
        public int Lives { get; set; }
        public List<IItem> Inventory { get; } = new List<IItem>();
        private readonly IGameStateManager _gameStateManager;
        public Player(int x, int y, int lives, IGameStateManager gameStateManager)
        {
            Position = new Coordinates(x, y);
            Lives = lives;
            _gameStateManager = gameStateManager;
        }
        public Coordinates GetNewPosition(Direction direction)
        {
            Coordinates movement = DirectionHelper.ToCoordinates(direction);
            return Position + movement;
        }
        public void UpdatePosition(Coordinates newPosition)
        {
            Position = newPosition;
        }
        public bool TryMove(Direction direction, Room currentRoom)
        {
            Coordinates newPosition = GetNewPosition(direction);
            if (newPosition.X < 0 || newPosition.X >= currentRoom.Width ||
                newPosition.Y < 0 || newPosition.Y >= currentRoom.Height)
            {
                // Outside room bounds
                return false;
            }
            if (!currentRoom.GetTileAt(newPosition).IsWalkable)
            {
                return false;
            }
            Position = newPosition;
            return true;
        }
        public void CollectItem(IItem item)
        {
            if (item.IsCollectible)
            {
                Inventory.Add(item);
                // If it's a Sankara Stone, let the GameStateManager know
                if (item is SankaraStoneDecorator)
                {
                    _gameStateManager.OnSankaraStoneCollected();
                }
            }
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Models\Room.cs
namespace TempleOfDoom.BusinessLogic.Models
{
    public class Room
    {
        private List<IDoor> _doors = new List<IDoor>();
        // Instead of storing EnemyDto, we store real Enemy objects from the DLL.
        public List<Enemy> Enemies { get; } = new List<Enemy>();
        public int Id { get; set; }
        public string Type { get; set; }
        public int Width { get; set; }
        public int Height { get; set; }
        // Your original tiles
        public ITile[,] Layout { get; private set; }
        // A parallel array of FieldAdapters (so each tile corresponds to one FieldAdapter).
        // This allows enemies to access the grid via IField.
        public FieldAdapter[,] FieldAdapters { get; private set; }
        public Room(int width, int height)
        {
            Width = width;
            Height = height;
            // We now create both Layout and FieldAdapters in GenerateLayout().
        }
        public ITile GetTileAt(Coordinates coordinates)
        {
            return Layout[coordinates.Y, coordinates.X];
        }
        /// <summary>
        /// Fills the Layout with walls on the outer boundary, floor tiles inside,
        /// and creates matching FieldAdapters for each cell.
        /// </summary>
        public void GenerateLayout()
        {
            Layout = new ITile[Height, Width];
            FieldAdapters = new FieldAdapter[Height, Width];
            for (int y = 0; y < Height; y++)
            {
                for (int x = 0; x < Width; x++)
                {
                    bool isWall = (x == 0 || y == 0 || x == Width - 1 || y == Height - 1);
                    if (isWall)
                    {
                        Layout[y, x] = new WallTile();
                    }
                    else
                    {
                        Layout[y, x] = new FloorTile();
                    }
                    // Create a FieldAdapter for the (x,y) cell that wraps this room & tile
                    FieldAdapter adapter = new FieldAdapter(this, x, y);
                    FieldAdapters[y, x] = adapter;
                }
            }
        }
        /// <summary>
        /// Places an item on the given FloorTile (if it’s actually a FloorTile).
        /// </summary>
        public void PlaceItem(Coordinates position, IItem item)
        {
            if (Layout[position.Y, position.X] is FloorTile floorTile)
            {
                floorTile.Item = item;
            }
        }
        /// <summary>
        /// Removes an item (if any) from a FloorTile at the given position.
        /// </summary>
        public void RemoveItemAt(Coordinates position)
        {
            if (Layout[position.Y, position.X] is FloorTile floorTile)
            {
                floorTile.Item = null;
            }
        }
        public void RegisterDoor(IDoor door)
        {
            if (!_doors.Contains(door))
            {
                _doors.Add(door);
            }
        }
        public IEnumerable<IDoor> GetDoors() => _doors;
        public IEnumerable<Coordinates> GetEnemyPositions()
        {
            // For each Enemy, create a Coordinates for its current location:
            return Enemies.Select(e => new Coordinates(e.CurrentXLocation, e.CurrentYLocation));
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Services\DoorService.cs
namespace TempleOfDoom.BusinessLogic.Services
{
    public class DoorService : IDoorService
    {
        // Check if door in the given direction can be opened
        public bool CanPassThroughDoor(Player player, Room room, Direction direction)
        {
            var doorPos = GetDoorPositionForDirection(room, direction);
            var doorTile = room.GetTileAt(doorPos) as DoorTile;
            if (doorTile == null) return true; // No door tile => passable
            return doorTile.Door.IsOpen(player, room);
        }
        public void AfterPassingDoor(Room room, Direction direction)
        {
            var doorPos = GetDoorPositionForDirection(room, direction);
            var doorTile = room.GetTileAt(doorPos) as DoorTile;
            // If the door is a "closing gate" decorator, then we call NotifyStateChange
            // so it can permanently close after the player passes through.
            if (doorTile != null && ContainsDoorOfType<ClosingGateDoorDecorator>(doorTile.Door))
            {
                doorTile.Door.NotifyStateChange();
            }
        }
        private Coordinates GetDoorPositionForDirection(Room room, Direction direction)
        {
            return direction switch
            {
                Direction.North => new Coordinates(room.Width / 2, 0),
                Direction.South => new Coordinates(room.Width / 2, room.Height - 1),
                Direction.West => new Coordinates(0, room.Height / 2),
                Direction.East => new Coordinates(room.Width - 1, room.Height / 2),
                _ => new Coordinates(1, 1)
            };
        }
        /// <summary>
        /// Recursively checks whether the given door is or contains 
        /// a decorator of type T somewhere in its wrapping chain.
        /// </summary>
        private bool ContainsDoorOfType<T>(IDoor door) where T : IDoor
        {
            // If the current door *is* T, we are done
            if (door is T) return true;
            // If it's a decorator, inspect its wrapped door
            if (door is DoorDecorator decorator)
            {
                return ContainsDoorOfType<T>(decorator.WrappedDoor);
            }
            // If it's neither T nor a decorator, there's nowhere else to look
            return false;
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Services\PlayerMovementController.cs
namespace TempleOfDoom.BusinessLogic.Services
{
    public class PlayerMovementController : IPlayerMovementController
    {
        private readonly IMovementStrategy _movementStrategy;
        private readonly IRoomTransitionService _roomTransitionService;
        private readonly IDoorService _doorService;
        private readonly IGameStateManager _gameStateManager;
        public PlayerMovementController(
            IMovementStrategy movementStrategy,
            IRoomTransitionService roomTransitionService,
            IDoorService doorService,
            IGameStateManager gameStateManager)
        {
            _movementStrategy = movementStrategy;
            _roomTransitionService = roomTransitionService;
            _doorService = doorService;
            _gameStateManager = gameStateManager;
        }
        public bool TryMovePlayer(Player player, Room currentRoom, Direction direction, out Room newCurrentRoom)
        {
            newCurrentRoom = currentRoom;
            if (_gameStateManager.IsGameOver) return false;
            Coordinates nextPos = _movementStrategy.GetNextPosition(player, currentRoom, direction);
            if (IsInsideRoom(nextPos, currentRoom))
            {
                // Movement inside this room
                if (IsPositionWalkable(currentRoom, player, nextPos))
                {
                    player.UpdatePosition(nextPos);
                    // Check if there's an item to interact with
                    if (currentRoom.GetTileAt(nextPos) is FloorTile floorTile && floorTile.Item != null)
                    {
                        bool removeItem = floorTile.Item.OnPlayerEnter(player, currentRoom);
                        // If player's lives are now <= 0, game over
                        if (player.Lives <= 0)
                        {
                            _gameStateManager.MarkLose();
                            return true;
                        }
                        // If OnPlayerEnter(...) says "true," remove the item
                        if (removeItem)
                        {
                            floorTile.Item = null;
                        }
                    }
                    return true;
                }
                return false;
            }
            else
            {
                // Attempt to pass through a door to another room
                if (_doorService.CanPassThroughDoor(player, currentRoom, direction))
                {
                    if (_roomTransitionService.TryTransition(currentRoom, player, direction, out var nextRoom))
                    {
                        // After transitioning, the player is now in nextRoom at the door’s entry position
                        // Optionally do the same item-check in the new room's position
                        if (nextRoom.GetTileAt(player.Position) is FloorTile floorTile && floorTile.Item != null)
                        {
                            bool removeItem = floorTile.Item.OnPlayerEnter(player, nextRoom);
                            if (player.Lives <= 0)
                            {
                                _gameStateManager.MarkLose();
                                return true;
                            }
                            if (removeItem)
                            {
                                floorTile.Item = null;
                            }
                        }
                        newCurrentRoom = nextRoom;
                        return true;
                    }
                }
            }
            return false;
        }
        private bool IsInsideRoom(Coordinates pos, Room room)
        {
            return pos.X >= 0 && pos.X < room.Width && pos.Y >= 0 && pos.Y < room.Height;
        }
        private bool IsPositionWalkable(Room room, Player player, Coordinates pos)
        {
            var tile = room.GetTileAt(pos);
            if (tile is DoorTile doorTile)
            {
                return doorTile.Door.IsOpen(player, room);
            }
            return tile.IsWalkable;
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Services\RoomTransitionService.cs
namespace TempleOfDoom.BusinessLogic.Services
{
    public class RoomTransitionService : IRoomTransitionService
    {
        private readonly Dictionary<int, Dictionary<Direction, int>> _roomConnections;
        private readonly IDoorService _doorService;
        private readonly Dictionary<int, Room> _roomsById; 
        public RoomTransitionService(Dictionary<int, Dictionary<Direction, int>> roomConnections, IDoorService doorService, Dictionary<int, Room> roomsById) 
        {
            _roomConnections = roomConnections;
            _doorService = doorService;
            _roomsById = roomsById; 
        }
        public bool TryTransition(Room currentRoom, Player player, Direction direction, out Room nextRoom)
        {
            nextRoom = null;
            if (!_roomConnections.TryGetValue(currentRoom.Id, out var connForRoom))
                return false;
            if (!connForRoom.TryGetValue(direction, out int nextRoomId))
                return false;
            _doorService.AfterPassingDoor(currentRoom, direction);
            nextRoom = GetNextRoom(nextRoomId);
            var entryPos = GetEntryPositionInNextRoom(nextRoom, OppositeDirection(direction));
            player.UpdatePosition(entryPos);
            return true;
        }
        private Room GetNextRoom(int roomId)
        {
            // CHANGED: no longer rely on GameService. Use _roomsById
            return _roomsById[roomId];
        }
        private Coordinates GetEntryPositionInNextRoom(Room nextRoom, Direction comingFromDirection)
        {
            return comingFromDirection switch
            {
                Direction.North => new Coordinates(nextRoom.Width / 2, 0),
                Direction.South => new Coordinates(nextRoom.Width / 2, nextRoom.Height - 1),
                Direction.West => new Coordinates(0, nextRoom.Height / 2),
                Direction.East => new Coordinates(nextRoom.Width - 1, nextRoom.Height / 2),
                _ => new Coordinates(1, 1)
            };
        }
        private Direction OppositeDirection(Direction direction)
        {
            return direction switch
            {
                Direction.North => Direction.South,
                Direction.South => Direction.North,
                Direction.East => Direction.West,
                Direction.West => Direction.East,
                _ => direction
            };
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Strategies\DefaultMovementStrategy.cs
namespace TempleOfDoom.BusinessLogic.Strategies
{
    public class DefaultMovementStrategy : IMovementStrategy
    {
        public Coordinates GetNextPosition(Player player, Room currentRoom, Direction direction)
        {
            Coordinates movement = DirectionHelper.ToCoordinates(direction);
            Coordinates newPosition = player.Position + movement;
            // Boundary checks and collision checks can be done here or delegated
            // to another service if needed.
            return newPosition;
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Structs\Coordinates.cs
namespace TempleOfDoom.BusinessLogic.Struct
{
    public struct Coordinates
    {
        public int X { get; }
        public int Y { get; }
        public Coordinates(int x, int y)
        {
            X = x;
            Y = y;
        }
        // Add useful methods and operators
        public static Coordinates operator +(Coordinates a, Coordinates b)
        {
            return new Coordinates(a.X + b.X, a.Y + b.Y);
        }
        public override string ToString()
        {
            return $"({X}, {Y})";
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Models\Doors\ClosingGateDoorDecorator.cs
namespace TempleOfDoom.BusinessLogic.Models.Doors
{
    public class ClosingGateDoorDecorator : DoorDecorator
    {
        private bool _hasClosed = false;
        public ClosingGateDoorDecorator(IDoor wrappedDoor)
            : base(wrappedDoor)
        {
        }
        public override bool IsOpen(Player player, Room currentRoom)
        {
            // As soon as it's passed once, we close forever
            // It's "open" only if not closed YET and the base chain is also open
            return !_hasClosed && base.IsOpen(player, currentRoom);
        }
        public override char GetRepresentation(bool isHorizontal)
        {
            return _hasClosed ? 'n' : ' ';
        }
        public override ConsoleColor GetColor()
        {
            return _hasClosed ? ConsoleColor.DarkMagenta : ConsoleColor.White;
        }
        public override void NotifyStateChange()
        {
            // after passing the door, we close it
            _hasClosed = true;
            // optionally call base
            base.NotifyStateChange();
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Models\Doors\ColoredDoorDecorator .cs
namespace TempleOfDoom.BusinessLogic.Models.Doors
{
    public class ColoredDoorDecorator : DoorDecorator
    {
        private readonly string _color;
        public ColoredDoorDecorator(IDoor wrappedDoor, string color)
            : base(wrappedDoor)
        {
            _color = color.ToLower();
        }
        public override char GetRepresentation(bool isHorizontal)
        {
            // Example: '=' for horizontal, '|' for vertical
            return isHorizontal ? '=' : '|';
        }
        public override ConsoleColor GetColor()
        {
            // Override the color based on _color
            return _color switch
            {
                "red" => ConsoleColor.Red,
                "green" => ConsoleColor.Green,
                _ => ConsoleColor.DarkGray
            };
        }
        public override bool IsOpen(Player player, Room currentRoom)
        {
            // Check if the player’s inventory contains a KeyDecorator of the matching color
            bool hasMatchingKey = player.Inventory.Any(i => i is KeyDecorator key
                                                         && key.Color.ToLower() == _color);
            // Only open if the player has that key AND the wrapped door is open
            return hasMatchingKey && base.IsOpen(player, currentRoom);
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Models\Doors\DefaultDoor.cs
namespace TempleOfDoom.BusinessLogic.Models.Doors
{
    public class DefaultDoor : IDoor
    {
        public virtual char GetRepresentation(bool isHorizontal) => ' ';
        public virtual ConsoleColor GetColor() => ConsoleColor.White;
        public virtual bool IsOpen(Player player, Room currentRoom) => true;
        public virtual void NotifyStateChange() { /* no-op */ }
    }
}

// File: TempleOfDoom.BusinessLogic\Models\Doors\OpenOnOddDoorDecorator.cs
namespace TempleOfDoom.BusinessLogic.Models.Doors
{
    public class OpenOnOddDoorDecorator : DoorDecorator
    {
        public OpenOnOddDoorDecorator(IDoor wrappedDoor)
            : base(wrappedDoor)
        { }
        public override char GetRepresentation(bool isHorizontal)
        {
            return base.GetRepresentation(isHorizontal);
        }
        public override ConsoleColor GetColor()
        {
            return base.GetColor();
        }
        public override bool IsOpen(Player player, Room currentRoom)
        {
            // Check base chain *and* the odd-lives condition
            return base.IsOpen(player, currentRoom) && (player.Lives % 2 != 0);
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Models\Doors\OpenOnStonesInRoomDecorator.cs
namespace TempleOfDoom.BusinessLogic.Models.Doors
{
    public class OpenOnStonesInRoomDecorator : DoorDecorator
    {
        private readonly int _requiredStones;
        public OpenOnStonesInRoomDecorator(IDoor wrappedDoor, int requiredStones)
            : base(wrappedDoor)
        {
            _requiredStones = requiredStones;
        }
        public override bool IsOpen(Player player, Room currentRoom)
        {
            // Count the Sankara stones in the current room:
            int stonesInRoom = 0;
            for (int y = 0; y < currentRoom.Height; y++)
            {
                for (int x = 0; x < currentRoom.Width; x++)
                {
                    var tile = currentRoom.GetTileAt(new Coordinates(x, y));
                    // If the tile is a FloorTile AND 
                    // that tile's item is a SankaraStoneDecorator, increment count
                    if (tile is FloorTile floorTile
                        && floorTile.Item is SankaraStoneDecorator)
                    {
                        stonesInRoom++;
                    }
                }
            }
            // Door only opens if:
            // 1) The base (wrapped) door is also open,
            // 2) The number of stones in the room == _requiredStones
            return base.IsOpen(player, currentRoom) && (stonesInRoom == _requiredStones);
        }
        public override char GetRepresentation(bool isHorizontal)
        {
            return base.GetRepresentation(isHorizontal);
        }
        public override ConsoleColor GetColor()
        {
            return base.GetColor();
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Models\Doors\PressurePlateDoor.cs
namespace TempleOfDoom.BusinessLogic.Models.Doors
{
    public class PressurePlateDoor : IDoor
    {
        public char GetRepresentation(bool isHorizontal) => '⊥';
        public ConsoleColor GetColor() => ConsoleColor.Cyan;
        public bool IsOpen(Player player, Room currentRoom)
        {
            // Placeholder: maybe always open for now
            return true;
        }
        public void NotifyStateChange() { /* Not used yet */ }
    }
}

// File: TempleOfDoom.BusinessLogic\Models\Doors\ToggleDoorDecorator.cs
namespace TempleOfDoom.BusinessLogic.Models.Doors
{
    public class ToggleDoorDecorator : DoorDecorator
    {
        private bool _isOpen = false; // default closed
        public ToggleDoorDecorator(IDoor wrappedDoor)
            : base(wrappedDoor)
        { }
        public override char GetRepresentation(bool isHorizontal)
        {
            // special toggle representation
            return '\u22A5'; // or any symbol you like
        }
        public override ConsoleColor GetColor()
        {
            // highlight toggles in yellow, for example
            return ConsoleColor.Yellow;
        }
        public override bool IsOpen(Player player, Room currentRoom)
        {
            // Must also be open in the chain above
            // Return true if BOTH chain is open and _isOpen is true
            return base.IsOpen(player, currentRoom) && _isOpen;
        }
        public override void NotifyStateChange()
        {
            // Flip state
            _isOpen = !_isOpen;
            // We also call base.NotifyStateChange if we want to let the rest 
            // of the chain know, or do something else. 
            base.NotifyStateChange();
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Models\Items\BaseItem.cs
namespace TempleOfDoom.BusinessLogic.Models.Items
{
    public class BaseItem : IItem
    {
        public string Name { get; protected set; } = "BaseItem";
        public virtual string Representation { get; protected set; } = "?";
        public virtual bool IsCollectible { get; protected set; } = false;
        public BaseItem() { }
        public BaseItem(string name, string representation, bool isCollectible)
        {
            Name = name;
            Representation = representation;
            IsCollectible = isCollectible;
        }
        public virtual bool OnPlayerEnter(Player player, Room currentRoom)
        {
            // By default, do nothing; return false = do not remove the item
            return false;
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Models\Items\BoobyTrapDecorator.cs
namespace TempleOfDoom.BusinessLogic.Models.Item.Item
{
    public class BoobyTrapDecorator : ItemDecorator
    {
        private readonly int _damage;
        public BoobyTrapDecorator(IItem wrappedItem, int damage) : base(wrappedItem)
        {
            _damage = damage;
        }
        public override string Name => "BoobyTrap"; // or combine with base, your choice
        public override string Representation => "O"; // or "B" if you prefer
        // It's still not collectible
        public override bool IsCollectible => false;
        public override bool OnPlayerEnter(Player player, Room currentRoom)
        {
            // Subtract lives
            player.Lives -= _damage;
            // Then delegate to the underlying item chain if you want
            // or just skip. Typically, if the underlying "base" is
            // empty, it won't do anything anyway:
            bool baseResult = base.OnPlayerEnter(player, currentRoom);
            // This does NOT remove itself (unless you also want “disappear”)
            return false;
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Models\Items\DisappearingBoobyTrapDecorator.cs
namespace TempleOfDoom.BusinessLogic.Models.Item.Item
{
    public class DisappearingBoobyTrapDecorator : ItemDecorator
    {
        private readonly int _damage;
        public DisappearingBoobyTrapDecorator(IItem wrappedItem, int damage)
            : base(wrappedItem)
        {
            _damage = damage;
        }
        public override string Name => "Disappearing BoobyTrap";
        public override string Representation => "@";
        public override bool IsCollectible => false;
        public override bool OnPlayerEnter(Player player, Room currentRoom)
        {
            // Deal damage to player
            player.Lives -= _damage;
            // Then remove the item (return true => remove from room after stepping)
            base.OnPlayerEnter(player, currentRoom);
            return true;
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Models\Items\KeyDecorator.cs
namespace TempleOfDoom.BusinessLogic.Models.Item.Item
{
    public class KeyDecorator : ItemDecorator
    {
        private readonly string _color;
        public KeyDecorator(IItem wrappedItem, string color)
            : base(wrappedItem)
        {
            _color = color;
        }
        public string Color => _color;  // <-- ADD THIS PROPERTY
        public override string Name => $"Key({_color})";
        public override string Representation => "K";
        public override bool IsCollectible => true;
        public override bool OnPlayerEnter(Player player, Room currentRoom)
        {
            player.CollectItem(this);
            return true; // remove from the floor
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Models\Items\PressurePlateDecorator.cs
namespace TempleOfDoom.BusinessLogic.Models.Items
{
    public class PressurePlateDecorator : ItemDecorator
    {
        public PressurePlateDecorator(IItem wrappedItem)
            : base(wrappedItem)
        {
        }
        public override string Name => "Pressure Plate";
        public override string Representation => "T";
        public override bool IsCollectible => false;
        public override bool OnPlayerEnter(Player player, Room currentRoom)
        {
            // Toggle all togglable doors in the room
            foreach (var door in currentRoom.GetDoors())
            {
                door.NotifyStateChange();
            }
            // Let base do whatever it does 
            base.OnPlayerEnter(player, currentRoom);
            // Typically, pressure plates remain, so return false
            return false;
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Models\Items\SankaraStoneDecorator.cs
namespace TempleOfDoom.BusinessLogic.Models.Items
{
    public class SankaraStoneDecorator : ItemDecorator
    {
        public SankaraStoneDecorator(IItem wrappedItem)
            : base(wrappedItem)
        {
        }
        public override string Name => "Sankara Stone";
        public override string Representation => "S";
        public override bool IsCollectible => true;
        public override bool OnPlayerEnter(Player player, Room currentRoom)
        {
            // Collect the stone
            player.CollectItem(this);
            // Remove from the room once picked up
            return true;
        }
    }
}

// File: TempleOfDoom.BusinessLogic\Models\Tile\DoorTile.cs
namespace TempleOfDoom.BusinessLogic.Models.Tile
{
    public class DoorTile : Tile
    {
        private readonly IDoor _door;
        private readonly bool _isHorizontal;
        // Add a public property to expose the door
        public IDoor Door => _door;
        public DoorTile(IDoor door, bool isHorizontal)
        {
            _door = door;
            _isHorizontal = isHorizontal;
        }
        public override string Representation => _door.GetRepresentation(_isHorizontal).ToString();
        public override bool IsWalkable => false;
        public ConsoleColor GetDoorColor() => _door.GetColor();
    }
}

// File: TempleOfDoom.BusinessLogic\Models\Tile\FloorTile.cs
namespace TempleOfDoom.BusinessLogic.Models.Tile
{
    public class FloorTile : Tile
    {
        public IItem Item { get; set; }  // optional, or pass in constructor
        public override string Representation
        {
            get
            {
                // If there's an item, show item’s representation
                if (Item != null) return Item.Representation;
                return " "; // empty floor
            }
        }
        public override bool IsWalkable => true;
    }
}

// File: TempleOfDoom.BusinessLogic\Models\Tile\Tile.cs
namespace TempleOfDoom.BusinessLogic.Models.Tile
{
    public abstract class Tile : ITile
    {
        public abstract string Representation { get; }
        public abstract bool IsWalkable { get; }
    }
}

// File: TempleOfDoom.BusinessLogic\Models\Tile\WallTile.cs
namespace TempleOfDoom.BusinessLogic.Models.Tile
{
    public class WallTile : Tile
    {
        public override string Representation => "#";
        public override bool IsWalkable => false;
    }
}

// File: TempleOfDoom.DataAccess\ConnectionDto.cs
namespace TempleOfDoom.DataAccess
{
    public class ConnectionDto
    {
        public int? NORTH { get; set; }
        public int? SOUTH { get; set; }
        public int? EAST { get; set; }
        public int? WEST { get; set; }
        public List<DoorDto> Doors { get; set; }
    }
}

// File: TempleOfDoom.DataAccess\DoorDto.cs
namespace TempleOfDoom.DataAccess
{
    public class DoorDto
    {
        public string Type { get; set; }
        public string Color { get; set; } // Nullable for optional properties
        public int? NoOfStones { get; set; } // Nullable for optional properties
    }
}

// File: TempleOfDoom.DataAccess\EnemyDto.cs
namespace TempleOfDoom.DataAccess
{
    public class EnemyDto
    {
        public string Type { get; set; }
        public int X { get; set; }
        public int Y { get; set; }
        public int MinX { get; set; }
        public int MinY { get; set; }
        public int MaxX { get; set; }
        public int MaxY { get; set; }
    }
}

// File: TempleOfDoom.DataAccess\ItemDto.cs
namespace TempleOfDoom.DataAccess
{
    public class ItemDto
    {
        public string Type { get; set; }
        public int? Damage { get; set; } // Nullable for optional properties
        public string Color { get; set; } // Nullable for optional properties
        public int X { get; set; }
        public int Y { get; set; }
    }
}

// File: TempleOfDoom.DataAccess\JsonLevelLoader.cs
namespace TempleOfDoom.DataAccess
{
    public class JsonLevelLoader
    {
        public LevelDto LoadLevel(string filePath)
        {
            if (!File.Exists(filePath))
            {
                throw new FileNotFoundException("JSON file not found.", filePath);
            }
            string jsonContent = File.ReadAllText(filePath);
            // Configure deserialization options
            JsonSerializerOptions options = new JsonSerializerOptions
            {
                PropertyNameCaseInsensitive = true // Makes JSON property names case-insensitive
            };
            LevelDto levelData = JsonSerializer.Deserialize<LevelDto>(jsonContent, options);
            return levelData;
        }
    }
}

// File: TempleOfDoom.DataAccess\LevelDto.cs
namespace TempleOfDoom.DataAccess
{
    public class LevelDto
    {
        public List<RoomDto> Rooms { get; set; }
        public List<ConnectionDto> Connections { get; set; }
        public PlayerDto Player { get; set; }
    }
}

// File: TempleOfDoom.DataAccess\PlayerDto.cs
namespace TempleOfDoom.DataAccess
{
    public class PlayerDto
    {
        public int StartRoomId { get; set; }
        public int StartX { get; set; }
        public int StartY { get; set; }
        public int Lives { get; set; }
    }
}

// File: TempleOfDoom.DataAccess\RoomDto.cs
namespace TempleOfDoom.DataAccess
{
    public class RoomDto
    {
        public int Id { get; set; }
        public string Type { get; set; }
        public int Width { get; set; }
        public int Height { get; set; }
        public List<ItemDto> Items { get; set; }
        public List<EnemyDto> Enemies { get; set; }
    }
}

